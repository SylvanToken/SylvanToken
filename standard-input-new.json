{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/IAdminWalletHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IAdminWalletHandler\r\n * @dev Interface for managing admin wallet configurations with immediate access\r\n */\r\ninterface IAdminWalletHandler {\r\n    /**\r\n     * @dev Admin wallet configuration structure\r\n     * @custom:optimization monthlyRelease field removed - calculated dynamically to save gas\r\n     */\r\n    struct AdminWalletConfig {\r\n        uint256 totalAllocation;     // Total token allocation\r\n        uint256 immediateRelease;    // 10% immediate release amount\r\n        uint256 lockedAmount;        // 90% locked amount\r\n        uint256 releasedAmount;      // Amount already released\r\n        uint256 burnedAmount;        // Amount burned during releases\r\n        bool isConfigured;           // Whether admin wallet is configured\r\n        bool immediateReleased;      // Whether immediate release was processed\r\n    }\r\n    \r\n    /**\r\n     * @dev Configure an admin wallet with allocation\r\n     * @param admin The admin wallet address\r\n     * @param allocation Total token allocation for the admin\r\n     */\r\n    function configureAdminWallet(address admin, uint256 allocation) external;\r\n    \r\n    /**\r\n     * @dev Get admin wallet configuration\r\n     * @param admin The admin wallet address\r\n     * @return AdminWalletConfig The admin configuration data\r\n     */\r\n    function getAdminConfig(address admin) external view returns (AdminWalletConfig memory);\r\n    \r\n    /**\r\n     * @dev Process initial 10% release for admin wallet\r\n     * @param admin The admin wallet address\r\n     * @return releasedAmount Amount released immediately\r\n     */\r\n    function processInitialRelease(address admin) external returns (uint256 releasedAmount);\r\n    \r\n    /**\r\n     * @dev Process monthly release for admin wallet\r\n     * @param admin The admin wallet address\r\n     * @return releasedAmount Amount released to admin (90% of calculated)\r\n     * @return burnedAmount Amount burned (10% of calculated)\r\n     */\r\n    function processMonthlyRelease(address admin) external returns (uint256 releasedAmount, uint256 burnedAmount);\r\n    \r\n    /**\r\n     * @dev Check if admin wallet is configured\r\n     * @param admin The admin wallet address\r\n     * @return bool True if admin wallet is configured\r\n     */\r\n    function isAdminConfigured(address admin) external view returns (bool);\r\n    \r\n    /**\r\n     * @dev Calculate available release amount for admin\r\n     * @param admin The admin wallet address\r\n     * @return availableAmount Amount available for release\r\n     * @return burnAmount Amount that will be burned\r\n     */\r\n    function calculateAvailableRelease(address admin) external view returns (uint256 availableAmount, uint256 burnAmount);\r\n    \r\n    /**\r\n     * @dev Get all configured admin wallets\r\n     * @return address[] Array of configured admin wallet addresses\r\n     */\r\n    function getConfiguredAdmins() external view returns (address[] memory);\r\n    \r\n    /**\r\n     * @dev Get total admin allocations\r\n     * @return uint256 Total amount allocated to all admin wallets\r\n     */\r\n    function getTotalAdminAllocations() external view returns (uint256);\r\n    \r\n    // Events\r\n    event AdminWalletConfigured(\r\n        address indexed admin,\r\n        uint256 totalAllocation,\r\n        uint256 immediateRelease,\r\n        uint256 lockedAmount\r\n    );\r\n    event InitialReleaseProcessed(address indexed admin, uint256 amount);\r\n    event MonthlyReleaseProcessed(\r\n        address indexed admin,\r\n        uint256 releasedAmount,\r\n        uint256 burnedAmount,\r\n        uint256 totalReleased\r\n    );\r\n}"
    },
    "contracts/interfaces/IEnhancedFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IEnhancedFeeManager\r\n * @dev Interface for managing dynamic fee exemptions with environment-based configuration\r\n */\r\ninterface IEnhancedFeeManager {\r\n    /**\r\n     * @dev Check if a wallet is exempt from fees\r\n     * @param wallet The wallet address to check\r\n     * @return bool True if wallet is exempt from fees\r\n     */\r\n    function isExempt(address wallet) external view returns (bool);\r\n    \r\n    /**\r\n     * @dev Add a wallet to the fee exemption list\r\n     * @param wallet The wallet address to add\r\n     */\r\n    function addExemptWallet(address wallet) external;\r\n    \r\n    /**\r\n     * @dev Remove a wallet from the fee exemption list\r\n     * @param wallet The wallet address to remove\r\n     */\r\n    function removeExemptWallet(address wallet) external;\r\n    \r\n    /**\r\n     * @dev Get all exempt wallets\r\n     * @return address[] Array of exempt wallet addresses\r\n     */\r\n    function getExemptWallets() external view returns (address[] memory);\r\n    \r\n    /**\r\n     * @dev Load exemptions from configuration\r\n     */\r\n    function loadExemptionsFromConfig() external;\r\n    \r\n    /**\r\n     * @dev Load exemptions from configuration data\r\n     * @param configWallets Array of wallet addresses to configure\r\n     * @param exemptStatuses Array of exemption statuses (true = exempt, false = not exempt)\r\n     */\r\n    function loadExemptionsFromConfig(\r\n        address[] calldata configWallets,\r\n        bool[] calldata exemptStatuses\r\n    ) external;\r\n    \r\n    /**\r\n     * @dev Add multiple wallets to exemption list in batch\r\n     * @param wallets Array of wallet addresses to add\r\n     */\r\n    function addExemptWalletsBatch(address[] calldata wallets) external;\r\n    \r\n    /**\r\n     * @dev Remove multiple wallets from exemption list in batch\r\n     * @param wallets Array of wallet addresses to remove\r\n     */\r\n    function removeExemptWalletsBatch(address[] calldata wallets) external;\r\n    \r\n    /**\r\n     * @dev Get the count of exempt wallets\r\n     * @return uint256 Number of exempt wallets\r\n     */\r\n    function getExemptWalletCount() external view returns (uint256);\r\n    \r\n    // Events\r\n    event FeeExemptionChanged(address indexed wallet, bool exempt);\r\n    event BatchExemptionUpdate(address[] wallets, bool exempt);\r\n    event ExemptionConfigLoaded(uint256 walletCount);\r\n}"
    },
    "contracts/interfaces/IPlatformIntegration.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IPlatformIntegration\r\n * @dev Interface for platform integration and compliance reporting\r\n */\r\ninterface IPlatformIntegration {\r\n    \r\n    // Platform compliance data structure\r\n    struct PlatformData {\r\n        bool isApproved;\r\n        uint256 score;\r\n        uint256 lastUpdated;\r\n        string status;\r\n    }\r\n    \r\n    // Security analysis structure\r\n    struct SecurityAnalysis {\r\n        bool hasHoneypotRisk;\r\n        bool hasRugPullRisk;\r\n        bool hasBlacklistFunction;\r\n        bool hasHiddenFunctions;\r\n        bool isOwnerRenounced;\r\n        bool isLiquidityLocked;\r\n        uint256 riskScore;\r\n        uint256 securityScore;\r\n    }\r\n    \r\n    // Trading metrics structure\r\n    struct TradingMetrics {\r\n        uint256 volume24h;\r\n        uint256 transactions24h;\r\n        uint256 uniqueTraders24h;\r\n        uint256 averageTransactionSize;\r\n        uint256 currentPrice;\r\n        uint256 priceChange24h;\r\n        uint256 marketCap;\r\n    }\r\n    \r\n    // Holder distribution structure\r\n    struct HolderDistribution {\r\n        uint256 totalHolders;\r\n        uint256 topHolderPercentage;\r\n        uint256 top10HoldersPercentage;\r\n        uint256 top100HoldersPercentage;\r\n        uint256 holderGrowthRate;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get platform compliance status\r\n     */\r\n    function getPlatformCompliance(string memory platform) external view returns (PlatformData memory);\r\n    \r\n    /**\r\n     * @dev Get comprehensive security analysis\r\n     */\r\n    function getSecurityAnalysis() external view returns (SecurityAnalysis memory);\r\n    \r\n    /**\r\n     * @dev Get trading metrics\r\n     */\r\n    function getTradingMetrics() external view returns (TradingMetrics memory);\r\n    \r\n    /**\r\n     * @dev Get holder distribution\r\n     */\r\n    function getHolderDistribution() external view returns (HolderDistribution memory);\r\n    \r\n    /**\r\n     * @dev Check if token is honeypot\r\n     */\r\n    function isHoneypot() external view returns (bool);\r\n    \r\n    /**\r\n     * @dev Check if token has rug pull risk\r\n     */\r\n    function hasRugPullRisk() external view returns (bool);\r\n    \r\n    /**\r\n     * @dev Get tax information\r\n     */\r\n    function getTaxInfo() external view returns (\r\n        uint256 buyTax,\r\n        uint256 sellTax,\r\n        bool hasTax,\r\n        bool isTransparent\r\n    );\r\n    \r\n    /**\r\n     * @dev Get liquidity information\r\n     */\r\n    function getLiquidityInfo() external view returns (\r\n        uint256 totalLiquidity,\r\n        bool isLocked,\r\n        uint256 lockDuration,\r\n        address[] memory pairs\r\n    );\r\n    \r\n    /**\r\n     * @dev Get contract verification status\r\n     */\r\n    function getVerificationStatus() external view returns (\r\n        bool isVerified,\r\n        bool isOpenSource,\r\n        bool hasAudit,\r\n        string memory auditReport\r\n    );\r\n}"
    },
    "contracts/interfaces/IVestingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IVestingManager\r\n * @dev Interface for managing token vesting schedules with proportional burning\r\n */\r\ninterface IVestingManager {\r\n    /**\r\n     * @dev Vesting schedule structure\r\n     */\r\n    struct VestingSchedule {\r\n        uint256 totalAmount;        // Total amount to be vested\r\n        uint256 releasedAmount;     // Amount already released\r\n        uint256 burnedAmount;       // Amount burned during releases\r\n        uint256 startTime;          // Vesting start timestamp\r\n        uint256 cliffDuration;      // Cliff period in seconds\r\n        uint256 vestingDuration;    // Total vesting duration in seconds\r\n        uint256 releasePercentage;  // Monthly release percentage (basis points)\r\n        uint256 burnPercentage;     // Burn percentage of releases (basis points)\r\n        bool isAdmin;               // Whether this is an admin wallet\r\n        bool isActive;              // Whether the vesting schedule is active\r\n    }\r\n    \r\n    /**\r\n     * @dev Create a new vesting schedule\r\n     * @param beneficiary The address that will receive vested tokens\r\n     * @param amount Total amount to be vested\r\n     * @param cliffDays Cliff period in days\r\n     * @param vestingMonths Total vesting period in months\r\n     * @param releasePercentage Monthly release percentage (basis points)\r\n     * @param burnPercentage Burn percentage of releases (basis points)\r\n     * @param isAdmin Whether this is an admin wallet\r\n     */\r\n    function createVestingSchedule(\r\n        address beneficiary,\r\n        uint256 amount,\r\n        uint256 cliffDays,\r\n        uint256 vestingMonths,\r\n        uint256 releasePercentage,\r\n        uint256 burnPercentage,\r\n        bool isAdmin\r\n    ) external;\r\n    \r\n    /**\r\n     * @dev Release vested tokens for a beneficiary\r\n     * @param beneficiary The address to release tokens for\r\n     * @return releasedAmount Amount of tokens released\r\n     * @return burnedAmount Amount of tokens burned\r\n     */\r\n    function releaseVestedTokens(address beneficiary) external returns (uint256 releasedAmount, uint256 burnedAmount);\r\n    \r\n    /**\r\n     * @dev Get vesting information for a beneficiary\r\n     * @param beneficiary The address to get vesting info for\r\n     * @return VestingSchedule The vesting schedule data\r\n     */\r\n    function getVestingInfo(address beneficiary) external view returns (VestingSchedule memory);\r\n    \r\n    /**\r\n     * @dev Calculate releasable amount for a beneficiary\r\n     * @param beneficiary The address to calculate for\r\n     * @return releasableAmount Amount that can be released\r\n     * @return burnAmount Amount that will be burned\r\n     */\r\n    function calculateReleasableAmount(address beneficiary) external view returns (uint256 releasableAmount, uint256 burnAmount);\r\n    \r\n    /**\r\n     * @dev Check if vesting schedule exists for beneficiary\r\n     * @param beneficiary The address to check\r\n     * @return bool True if vesting schedule exists\r\n     */\r\n    function hasVestingSchedule(address beneficiary) external view returns (bool);\r\n    \r\n    /**\r\n     * @dev Get total vested amount across all schedules\r\n     * @return uint256 Total amount being vested\r\n     */\r\n    function getTotalVestedAmount() external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Get total released amount across all schedules\r\n     * @return uint256 Total amount released\r\n     */\r\n    function getTotalReleasedAmount() external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Get total burned amount across all schedules\r\n     * @return uint256 Total amount burned\r\n     */\r\n    function getTotalBurnedAmount() external view returns (uint256);\r\n    \r\n    // Events\r\n    event VestingScheduleCreated(\r\n        address indexed beneficiary,\r\n        uint256 amount,\r\n        uint256 cliffDuration,\r\n        uint256 vestingDuration,\r\n        bool isAdmin\r\n    );\r\n    event TokensReleased(\r\n        address indexed beneficiary,\r\n        uint256 releasedAmount,\r\n        uint256 burnedAmount,\r\n        uint256 totalReleased\r\n    );\r\n    event VestingScheduleRevoked(address indexed beneficiary, uint256 unreleased);\r\n}"
    },
    "contracts/libraries/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/**\r\n * @title AccessControlLib\r\n * @dev Library for managing access control, cooldowns, and ownership transfers\r\n * @notice This library provides secure access control mechanisms with cooldown periods\r\n * @custom:security Pause mechanism removed - SafeWallet multisig used for governance\r\n */\r\nlibrary AccessControlLib {\r\n    \r\n    // Constants\r\n    uint256 public constant ADMIN_COOLDOWN = 1 hours;\r\n    uint256 public constant OWNERSHIP_TIMELOCK = 24 hours;\r\n    \r\n    /**\r\n     * @dev Access control data structure\r\n     * @notice Pause-related fields removed - SafeWallet multisig handles governance\r\n     */\r\n    struct AccessData {\r\n        uint256 ownershipTransferInitiatedAt;        // Timestamp when ownership transfer was initiated\r\n        address pendingOwner;                        // Address of pending new owner\r\n        mapping(bytes4 => uint256) lastAdminAction;  // Cooldown tracking for admin actions\r\n    }\r\n\r\n    // Events\r\n    event OwnershipTransferInitiated(address indexed currentOwner, address indexed pendingOwner, uint256 timestamp);\r\n    event OwnershipTransferCompleted(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipTransferCancelled(address indexed owner, address indexed cancelledPendingOwner);\r\n    event AdminCooldownTriggered(bytes4 indexed functionSig, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev Check owner permissions with cooldown enforcement\r\n     * @param data Access control data storage reference\r\n     * @param functionSig Function signature for cooldown tracking\r\n     * @param caller Address of the caller\r\n     * @param owner Address of the contract owner\r\n     */\r\n    function checkOwnerWithCooldown(\r\n        AccessData storage data,\r\n        bytes4 functionSig,\r\n        address caller,\r\n        address owner\r\n    ) external {\r\n        require(owner == caller, \"Ownable: caller is not the owner\");\r\n        require(\r\n            block.timestamp >= data.lastAdminAction[functionSig] + ADMIN_COOLDOWN,\r\n            \"Cooldown period not elapsed\"\r\n        );\r\n        \r\n        data.lastAdminAction[functionSig] = block.timestamp;\r\n        emit AdminCooldownTriggered(functionSig, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if caller is the pending owner\r\n     * @param data Access control data storage reference\r\n     * @param caller Address of the caller\r\n     */\r\n    function requirePendingOwner(AccessData storage data, address caller) external view {\r\n        require(caller == data.pendingOwner, \"Caller is not the pending owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Initiate ownership transfer with timelock\r\n     * @param data Access control data storage reference\r\n     * @param newOwner Address of the new owner\r\n     * @param currentOwner Address of the current owner\r\n     */\r\n    function initiateOwnershipTransfer(\r\n        AccessData storage data,\r\n        address newOwner,\r\n        address currentOwner\r\n    ) external {\r\n        require(newOwner != address(0), \"New owner cannot be zero address\");\r\n        require(newOwner != currentOwner, \"New owner cannot be current owner\");\r\n        require(data.pendingOwner == address(0), \"Ownership transfer already initiated\");\r\n        \r\n        data.pendingOwner = newOwner;\r\n        data.ownershipTransferInitiatedAt = block.timestamp;\r\n        \r\n        emit OwnershipTransferInitiated(currentOwner, newOwner, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Complete ownership transfer after timelock\r\n     * @param data Access control data storage reference\r\n     * @param caller Address attempting to complete the transfer\r\n     * @return previousOwner Address of the previous owner\r\n     * @return newOwner Address of the new owner\r\n     */\r\n    function completeOwnershipTransfer(\r\n        AccessData storage data,\r\n        address caller\r\n    ) external returns (address previousOwner, address newOwner) {\r\n        require(caller == data.pendingOwner, \"Caller is not the pending owner\");\r\n        require(data.ownershipTransferInitiatedAt != 0, \"Ownership transfer not initiated\");\r\n        require(\r\n            block.timestamp >= data.ownershipTransferInitiatedAt + OWNERSHIP_TIMELOCK,\r\n            \"Ownership transfer timelock not elapsed\"\r\n        );\r\n        \r\n        previousOwner = data.pendingOwner;\r\n        newOwner = data.pendingOwner;\r\n        \r\n        // Reset transfer state\r\n        data.pendingOwner = address(0);\r\n        data.ownershipTransferInitiatedAt = 0;\r\n        \r\n        emit OwnershipTransferCompleted(previousOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel pending ownership transfer\r\n     * @param data Access control data storage reference\r\n     * @param owner Address of the current owner\r\n     */\r\n    function cancelOwnershipTransfer(AccessData storage data, address owner) external {\r\n        require(data.pendingOwner != address(0), \"No pending ownership transfer\");\r\n        \r\n        address cancelledPendingOwner = data.pendingOwner;\r\n        data.pendingOwner = address(0);\r\n        data.ownershipTransferInitiatedAt = 0;\r\n        \r\n        emit OwnershipTransferCancelled(owner, cancelledPendingOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Get ownership transfer status\r\n     * @param data Access control data storage reference\r\n     * @return isPending Whether there is a pending ownership transfer\r\n     * @return pendingOwner Address of the pending owner\r\n     * @return initiatedAt Timestamp when transfer was initiated\r\n     * @return canComplete Whether the transfer can be completed now\r\n     */\r\n    function getOwnershipTransferStatus(AccessData storage data)\r\n        external\r\n        view\r\n        returns (\r\n            bool isPending,\r\n            address pendingOwner,\r\n            uint256 initiatedAt,\r\n            bool canComplete\r\n        )\r\n    {\r\n        isPending = data.pendingOwner != address(0);\r\n        pendingOwner = data.pendingOwner;\r\n        initiatedAt = data.ownershipTransferInitiatedAt;\r\n        \r\n        if (isPending) {\r\n            canComplete = block.timestamp >= data.ownershipTransferInitiatedAt + OWNERSHIP_TIMELOCK;\r\n        } else {\r\n            canComplete = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get last admin action timestamp for a function\r\n     * @param data Access control data storage reference\r\n     * @param functionSig Function signature to check\r\n     * @return timestamp Last time the function was called\r\n     */\r\n    function getLastAdminAction(AccessData storage data, bytes4 functionSig)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return data.lastAdminAction[functionSig];\r\n    }\r\n\r\n    /**\r\n     * @dev Check if cooldown period has elapsed for a function\r\n     * @param data Access control data storage reference\r\n     * @param functionSig Function signature to check\r\n     * @return canExecute Whether the function can be executed now\r\n     * @return timeRemaining Time remaining in cooldown (0 if can execute)\r\n     */\r\n    function checkCooldown(AccessData storage data, bytes4 functionSig)\r\n        external\r\n        view\r\n        returns (bool canExecute, uint256 timeRemaining)\r\n    {\r\n        uint256 lastAction = data.lastAdminAction[functionSig];\r\n        uint256 nextAllowedTime = lastAction + ADMIN_COOLDOWN;\r\n        \r\n        if (block.timestamp >= nextAllowedTime) {\r\n            canExecute = true;\r\n            timeRemaining = 0;\r\n        } else {\r\n            canExecute = false;\r\n            timeRemaining = nextAllowedTime - block.timestamp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validate ownership transfer parameters\r\n     * @param newOwner Address of the proposed new owner\r\n     * @param currentOwner Address of the current owner\r\n     * @param contractAddress Address of the contract\r\n     */\r\n    function validateOwnershipTransfer(\r\n        address newOwner,\r\n        address currentOwner,\r\n        address contractAddress\r\n    ) external pure {\r\n        require(newOwner != address(0), \"New owner cannot be zero address\");\r\n        require(newOwner != currentOwner, \"New owner cannot be current owner\");\r\n        require(newOwner != contractAddress, \"New owner cannot be contract address\");\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/EmergencyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title EmergencyManager\r\n * @dev Library for handling emergency withdraw functionality with timelock security\r\n * @notice This library provides secure emergency withdrawal mechanisms with proper validation\r\n */\r\nlibrary EmergencyManager {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Constants\r\n    uint256 public constant EMERGENCY_TIMELOCK = 2 days;\r\n    uint256 public constant EMERGENCY_WINDOW = 1 hours;\r\n\r\n    /**\r\n     * @dev Emergency data structure for managing withdrawal state\r\n     */\r\n    struct EmergencyData {\r\n        uint256 unlockTime;                           // When emergency withdraw becomes available\r\n        mapping(address => uint256) withdrawHistory;  // History of withdrawals per token\r\n        uint256 totalWithdrawn;                      // Total amount withdrawn across all tokens\r\n    }\r\n\r\n    // Events\r\n    event EmergencyWithdrawEnabled(uint256 unlockTime);\r\n    event EmergencyWithdrawCancelled();\r\n    event EmergencyWithdraw(address indexed token, uint256 amount);\r\n    event EmergencyWithdrawHistoryUpdated(address indexed token, uint256 amount, uint256 totalWithdrawn);\r\n\r\n    /**\r\n     * @dev Enable emergency withdraw with timelock\r\n     * @param data Emergency data storage reference\r\n     */\r\n    function enableEmergencyWithdraw(EmergencyData storage data) external {\r\n        require(data.unlockTime == 0, \"Emergency withdraw already enabled\");\r\n        \r\n        data.unlockTime = block.timestamp + EMERGENCY_TIMELOCK;\r\n        \r\n        emit EmergencyWithdrawEnabled(data.unlockTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel emergency withdraw before timelock expires\r\n     * @param data Emergency data storage reference\r\n     */\r\n    function cancelEmergencyWithdraw(EmergencyData storage data) external {\r\n        require(data.unlockTime != 0, \"Emergency withdraw not enabled\");\r\n        require(block.timestamp < data.unlockTime, \"Emergency withdraw timelock already passed\");\r\n        \r\n        data.unlockTime = 0;\r\n        emit EmergencyWithdrawCancelled();\r\n    }\r\n\r\n    /**\r\n     * @dev Execute emergency withdrawal of tokens or ETH\r\n     * @param data Emergency data storage reference\r\n     * @param token Token address (address(0) for ETH)\r\n     * @param amount Amount to withdraw\r\n     * @param recipient Address to receive the withdrawn funds\r\n     */\r\n    function executeEmergencyWithdraw(\r\n        EmergencyData storage data,\r\n        address token,\r\n        uint256 amount,\r\n        address payable recipient\r\n    ) external {\r\n        // Validate timelock conditions\r\n        require(data.unlockTime != 0 && block.timestamp >= data.unlockTime, \r\n            \"Emergency withdraw timelock not passed\");\r\n        require(block.timestamp <= data.unlockTime + EMERGENCY_WINDOW,\r\n            \"Emergency withdraw window expired\");\r\n        \r\n        // Validate inputs\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(recipient != address(0), \"Invalid recipient address\");\r\n        \r\n        // Check balance and execute withdrawal\r\n        if (token == address(0)) {\r\n            // ETH withdrawal\r\n            require(address(this).balance >= amount, \"Insufficient ETH balance\");\r\n            recipient.transfer(amount);\r\n        } else {\r\n            // ERC20 token withdrawal\r\n            IERC20 tokenContract = IERC20(token);\r\n            require(tokenContract.balanceOf(address(this)) >= amount, \"Insufficient token balance\");\r\n            tokenContract.safeTransfer(recipient, amount);\r\n        }\r\n        \r\n        // Update history and reset state\r\n        data.withdrawHistory[token] += amount;\r\n        data.totalWithdrawn += amount;\r\n        data.unlockTime = 0; // Reset timelock after successful withdrawal\r\n        \r\n        emit EmergencyWithdraw(token, amount);\r\n        emit EmergencyWithdrawHistoryUpdated(token, amount, data.withdrawHistory[token]);\r\n    }\r\n\r\n    /**\r\n     * @dev Get current emergency withdraw status\r\n     * @param data Emergency data storage reference\r\n     * @return isEnabled Whether emergency withdraw is enabled\r\n     * @return unlockTime When the timelock expires\r\n     * @return canWithdraw Whether withdrawal is currently possible\r\n     * @return hasExpired Whether the withdrawal window has expired\r\n     */\r\n    function getEmergencyStatus(EmergencyData storage data) \r\n        external \r\n        view \r\n        returns (\r\n            bool isEnabled,\r\n            uint256 unlockTime,\r\n            bool canWithdraw,\r\n            bool hasExpired\r\n        ) \r\n    {\r\n        isEnabled = data.unlockTime != 0;\r\n        unlockTime = data.unlockTime;\r\n        \r\n        if (isEnabled) {\r\n            canWithdraw = block.timestamp >= data.unlockTime && \r\n                         block.timestamp <= data.unlockTime + EMERGENCY_WINDOW;\r\n            hasExpired = block.timestamp > data.unlockTime + EMERGENCY_WINDOW;\r\n        } else {\r\n            canWithdraw = false;\r\n            hasExpired = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get emergency withdraw statistics for a specific token\r\n     * @param data Emergency data storage reference\r\n     * @param token Token address to check (address(0) for ETH)\r\n     * @return withdrawnAmount Total amount withdrawn for this token\r\n     * @return totalWithdrawn Total amount withdrawn across all tokens\r\n     * @return contractBalance Current contract balance for this token\r\n     */\r\n    function getEmergencyStats(EmergencyData storage data, address token)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 withdrawnAmount,\r\n            uint256 totalWithdrawn,\r\n            uint256 contractBalance\r\n        )\r\n    {\r\n        withdrawnAmount = data.withdrawHistory[token];\r\n        totalWithdrawn = data.totalWithdrawn;\r\n        \r\n        if (token == address(0)) {\r\n            contractBalance = address(this).balance;\r\n        } else {\r\n            contractBalance = IERC20(token).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validate emergency withdraw conditions without executing\r\n     * @param data Emergency data storage reference\r\n     * @param token Token address to validate\r\n     * @param amount Amount to validate\r\n     * @return isValid Whether the withdrawal would be valid\r\n     * @return errorMessage Error message if not valid\r\n     */\r\n    function validateEmergencyWithdraw(\r\n        EmergencyData storage data,\r\n        address token,\r\n        uint256 amount\r\n    ) external view returns (bool isValid, string memory errorMessage) {\r\n        // Check timelock conditions\r\n        if (data.unlockTime == 0) {\r\n            return (false, \"Emergency withdraw not enabled\");\r\n        }\r\n        \r\n        if (block.timestamp < data.unlockTime) {\r\n            return (false, \"Emergency withdraw timelock not passed\");\r\n        }\r\n        \r\n        if (block.timestamp > data.unlockTime + EMERGENCY_WINDOW) {\r\n            return (false, \"Emergency withdraw window expired\");\r\n        }\r\n        \r\n        // Check amount\r\n        if (amount == 0) {\r\n            return (false, \"Amount must be greater than zero\");\r\n        }\r\n        \r\n        // Check balance\r\n        uint256 balance;\r\n        if (token == address(0)) {\r\n            balance = address(this).balance;\r\n        } else {\r\n            balance = IERC20(token).balanceOf(address(this));\r\n        }\r\n        \r\n        if (balance < amount) {\r\n            return (false, \"Insufficient balance\");\r\n        }\r\n        \r\n        return (true, \"\");\r\n    }\r\n}"
    },
    "contracts/libraries/InputValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/**\r\n * @title InputValidator\r\n * @dev Library for comprehensive input validation and security checks\r\n * @notice This library provides reusable validation functions for addresses, amounts, and arrays\r\n */\r\nlibrary InputValidator {\r\n    \r\n    // Constants for validation\r\n    uint256 public constant MAX_ARRAY_LENGTH = 100;\r\n    uint256 public constant MIN_TRANSFER_AMOUNT = 1;\r\n    \r\n    /**\r\n     * @dev Validate a single address with custom message\r\n     * @param addr Address to validate\r\n     * @param errorMessage Custom error message\r\n     */\r\n    function validateAddressWithMessage(address addr, string memory errorMessage) external pure {\r\n        require(addr != address(0), errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate address is not zero\r\n     * @param addr Address to validate\r\n     */\r\n    function validateAddress(address addr) external pure {\r\n        require(addr != address(0), \"Invalid address: cannot be zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate address is not contract address\r\n     * @param addr Address to validate\r\n     * @param contractAddress Contract address to check against\r\n     */\r\n    function validateNotContract(address addr, address contractAddress) external pure {\r\n        require(addr != contractAddress, \"Invalid address: cannot be contract address\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate wallet pair addresses\r\n     * @param wallet1 First wallet address\r\n     * @param wallet2 Second wallet address\r\n     * @param contractAddress Contract address to check against\r\n     */\r\n    function validateWalletPair(\r\n        address wallet1,\r\n        address wallet2,\r\n        address contractAddress\r\n    ) external pure {\r\n        require(wallet1 != address(0), \"Invalid first wallet address\");\r\n        require(wallet2 != address(0), \"Invalid second wallet address\");\r\n        require(wallet1 != contractAddress, \"First wallet cannot be contract address\");\r\n        require(wallet2 != contractAddress, \"Second wallet cannot be contract address\");\r\n        require(wallet1 != wallet2, \"Wallets cannot be the same\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate transfer amount\r\n     * @param amount Amount to validate\r\n     */\r\n    function validateAmount(uint256 amount) external pure {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate transfer amount with minimum threshold\r\n     * @param amount Amount to validate\r\n     * @param minAmount Minimum allowed amount\r\n     */\r\n    function validateAmountWithMin(uint256 amount, uint256 minAmount) external pure {\r\n        require(amount >= minAmount, \"Amount below minimum threshold\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate transfer addresses\r\n     * @param from Sender address\r\n     * @param to Recipient address\r\n     */\r\n    function validateTransferAddresses(address from, address to) external pure {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(from != to, \"Cannot transfer to self\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate array length\r\n     * @param arrayLength Length of array to validate\r\n     */\r\n    function validateArrayLength(uint256 arrayLength) external pure {\r\n        require(arrayLength > 0, \"Array cannot be empty\");\r\n        require(arrayLength <= MAX_ARRAY_LENGTH, \"Array too large\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate two arrays have same length\r\n     * @param array1Length Length of first array\r\n     * @param array2Length Length of second array\r\n     */\r\n    function validateArrayLengths(uint256 array1Length, uint256 array2Length) external pure {\r\n        require(array1Length == array2Length, \"Array lengths must match\");\r\n        require(array1Length > 0, \"Array cannot be empty\");\r\n        require(array1Length <= MAX_ARRAY_LENGTH, \"Array too large\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate address array for duplicates and zero addresses\r\n     * @param addresses Array of addresses to validate\r\n     */\r\n    function validateAddressArray(address[] memory addresses) external pure {\r\n        require(addresses.length > 0, \"Array cannot be empty\");\r\n        require(addresses.length <= MAX_ARRAY_LENGTH, \"Array too large\");\r\n        \r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            require(addresses[i] != address(0), \"Invalid address in array\");\r\n            \r\n            // Check for duplicates\r\n            for (uint256 j = i + 1; j < addresses.length; j++) {\r\n                require(addresses[i] != addresses[j], \"Duplicate address in array\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validate ownership transfer parameters\r\n     * @param newOwner New owner address\r\n     * @param currentOwner Current owner address\r\n     * @param contractAddress Contract address\r\n     */\r\n    function validateOwnershipTransfer(\r\n        address newOwner,\r\n        address currentOwner,\r\n        address contractAddress\r\n    ) external pure {\r\n        require(newOwner != address(0), \"New owner cannot be zero address\");\r\n        require(newOwner != currentOwner, \"New owner cannot be current owner\");\r\n        require(newOwner != contractAddress, \"New owner cannot be contract address\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate wallet update parameters\r\n     * @param newWallet New wallet address\r\n     * @param currentWallet Current wallet address\r\n     * @param contractAddress Contract address\r\n     */\r\n    function validateWalletUpdate(\r\n        address newWallet,\r\n        address currentWallet,\r\n        address contractAddress\r\n    ) external pure {\r\n        require(newWallet != address(0), \"Invalid wallet address\");\r\n        require(newWallet != contractAddress, \"Cannot be contract address\");\r\n        require(newWallet != currentWallet, \"Same as current wallet\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate AMM pair setting\r\n     * @param pair AMM pair address\r\n     * @param contractAddress Contract address\r\n     * @param owner Owner address\r\n     * @param feeWallet Fee wallet address\r\n     * @param donationWallet Donation wallet address\r\n     */\r\n    function validateAMMPair(\r\n        address pair,\r\n        address contractAddress,\r\n        address owner,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external pure {\r\n        require(pair != address(0), \"Invalid pair address\");\r\n        require(pair != contractAddress, \"Cannot set contract as AMM pair\");\r\n        require(pair != owner, \"Cannot set owner as AMM pair\");\r\n        require(pair != feeWallet, \"Cannot set fee wallet as AMM pair\");\r\n        require(pair != donationWallet, \"Cannot set donation wallet as AMM pair\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate emergency withdraw parameters\r\n     * @param token Token address (can be zero for ETH)\r\n     * @param amount Amount to withdraw\r\n     * @param recipient Recipient address\r\n     */\r\n    function validateEmergencyWithdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) external pure {\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(recipient != address(0), \"Invalid recipient address\");\r\n        // Note: token can be address(0) for ETH, so we don't validate it\r\n    }\r\n\r\n    /**\r\n     * @dev Validate tax exemption parameters\r\n     * @param account Account address\r\n     * @param exempt Exemption status\r\n     * @param owner Owner address\r\n     * @param contractAddress Contract address\r\n     * @param feeWallet Fee wallet address\r\n     * @param donationWallet Donation wallet address\r\n     */\r\n    function validateTaxExemption(\r\n        address account,\r\n        bool exempt,\r\n        address owner,\r\n        address contractAddress,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external pure {\r\n        require(account != address(0), \"Invalid account address\");\r\n        \r\n        // Prevent removing exemption from critical addresses\r\n        if (!exempt) {\r\n            require(account != contractAddress, \"Contract must remain tax exempt\");\r\n            require(account != owner, \"Owner must remain tax exempt\");\r\n            require(account != feeWallet, \"Fee wallet must remain tax exempt\");\r\n            require(account != donationWallet, \"Donation wallet must remain tax exempt\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validate percentage value (0-10000 basis points)\r\n     * @param percentage Percentage in basis points\r\n     * @param maxPercentage Maximum allowed percentage\r\n     */\r\n    function validatePercentage(uint256 percentage, uint256 maxPercentage) external pure {\r\n        require(percentage <= maxPercentage, \"Percentage exceeds maximum\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate timelock parameters\r\n     * @param unlockTime Unlock timestamp\r\n     * @param currentTime Current timestamp\r\n     * @param minDelay Minimum delay required\r\n     */\r\n    function validateTimelock(\r\n        uint256 unlockTime,\r\n        uint256 currentTime,\r\n        uint256 minDelay\r\n    ) external pure {\r\n        require(unlockTime > currentTime, \"Unlock time must be in future\");\r\n        require(unlockTime >= currentTime + minDelay, \"Insufficient delay\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate cooldown period\r\n     * @param lastAction Timestamp of last action\r\n     * @param currentTime Current timestamp\r\n     * @param cooldownPeriod Required cooldown period\r\n     */\r\n    function validateCooldown(\r\n        uint256 lastAction,\r\n        uint256 currentTime,\r\n        uint256 cooldownPeriod\r\n    ) external pure {\r\n        require(\r\n            currentTime >= lastAction + cooldownPeriod,\r\n            \"Cooldown period not elapsed\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Validate balance sufficiency\r\n     * @param balance Available balance\r\n     * @param amount Required amount\r\n     */\r\n    function validateBalance(uint256 balance, uint256 amount) external pure {\r\n        require(balance >= amount, \"Insufficient balance\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate contract state for operations\r\n     * @param isPaused Whether contract is paused\r\n     * @param tradingEnabled Whether trading is enabled\r\n     * @param requireTrading Whether operation requires trading to be enabled\r\n     */\r\n    function validateContractState(\r\n        bool isPaused,\r\n        bool tradingEnabled,\r\n        bool requireTrading\r\n    ) external pure {\r\n        require(!isPaused, \"Contract is paused\");\r\n        if (requireTrading) {\r\n            require(tradingEnabled, \"Trading not enabled\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Comprehensive validation for constructor parameters\r\n     * @param feeWallet Fee wallet address\r\n     * @param donationWallet Donation wallet address\r\n     * @param contractAddress Contract address\r\n     * @param initialExemptAccounts Array of initially exempt accounts\r\n     */\r\n    function validateConstructorParams(\r\n        address feeWallet,\r\n        address donationWallet,\r\n        address contractAddress,\r\n        address[] memory initialExemptAccounts\r\n    ) external pure {\r\n        require(feeWallet != address(0), \"Invalid fee wallet address\");\r\n        require(donationWallet != address(0), \"Invalid donation wallet address\");\r\n        require(feeWallet != contractAddress, \"Fee wallet cannot be contract address\");\r\n        require(donationWallet != contractAddress, \"Donation wallet cannot be contract address\");\r\n        require(feeWallet != donationWallet, \"Wallets cannot be the same\");\r\n        \r\n        if (initialExemptAccounts.length > 0) {\r\n            require(initialExemptAccounts.length <= MAX_ARRAY_LENGTH, \"Array too large\");\r\n            \r\n            for (uint256 i = 0; i < initialExemptAccounts.length; i++) {\r\n                require(initialExemptAccounts[i] != address(0), \"Invalid address in array\");\r\n                \r\n                // Check for duplicates\r\n                for (uint256 j = i + 1; j < initialExemptAccounts.length; j++) {\r\n                    require(initialExemptAccounts[i] != initialExemptAccounts[j], \"Duplicate address in array\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
    },
    "contracts/libraries/TaxManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title TaxManager\r\n * @dev Library for managing tax calculations and distributions\r\n * @notice This library provides tax calculation and distribution mechanisms for token transfers\r\n */\r\nlibrary TaxManager {\r\n    \r\n    // Constants\r\n    uint256 public constant TAX_RATE = 100;           // 1% = 100/10000\r\n    uint256 public constant TAX_DENOMINATOR = 10000;\r\n    uint256 public constant FEE_SHARE = 5000;         // 50%\r\n    uint256 public constant BURN_SHARE = 2500;        // 25%\r\n    uint256 public constant DONATION_SHARE = 2500;    // 25%\r\n    address public constant BURN_WALLET = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    /**\r\n     * @dev Tax data structure for managing tax-related state\r\n     */\r\n    struct TaxData {\r\n        mapping(address => bool) isAMMPair;      // AMM pair addresses\r\n        bool tradingEnabled;                     // Whether trading is enabled\r\n    }\r\n\r\n    // Events\r\n    event TradingEnabled();\r\n    event AMMPairUpdated(address indexed pair, bool status);\r\n    event TaxDistributed(uint256 feeAmount, uint256 burnAmount, uint256 donationAmount);\r\n    event TransferAnalytics(address indexed user, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev Enable trading\r\n     * @param data Tax data storage reference\r\n     */\r\n    function enableTrading(TaxData storage data) external {\r\n        require(!data.tradingEnabled, \"Trading already enabled\");\r\n        data.tradingEnabled = true;\r\n        emit TradingEnabled();\r\n    }\r\n\r\n    /**\r\n     * @dev Set AMM pair status\r\n     * @param data Tax data storage reference\r\n     * @param pair Address to set as AMM pair\r\n     * @param isPair Whether the address is an AMM pair\r\n     * @param owner Contract owner address\r\n     * @param feeWallet Fee wallet address\r\n     * @param donationWallet Donation wallet address\r\n     */\r\n    function setAMMPair(\r\n        TaxData storage data,\r\n        address pair,\r\n        bool isPair,\r\n        address owner,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external {\r\n        require(pair != address(0), \"Invalid pair address\");\r\n        \r\n        if (isPair) {\r\n            require(pair != owner, \"Cannot set owner as AMM pair\");\r\n            require(pair != feeWallet, \"Cannot set fee wallet as AMM pair\");\r\n            require(pair != donationWallet, \"Cannot set donation wallet as AMM pair\");\r\n            require(pair != BURN_WALLET, \"Cannot set burn wallet as AMM pair\");\r\n        }\r\n        \r\n        data.isAMMPair[pair] = isPair;\r\n        emit AMMPairUpdated(pair, isPair);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate tax amount for a given transfer amount\r\n     * @param amount Transfer amount\r\n     * @return taxAmount Calculated tax amount\r\n     */\r\n    function calculateTaxAmount(uint256 amount) external pure returns (uint256) {\r\n        return (amount * TAX_RATE) / TAX_DENOMINATOR;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate tax distribution amounts\r\n     * @param taxAmount Total tax amount to distribute\r\n     * @return feeAmount Amount going to fee wallet\r\n     * @return burnAmount Amount going to burn wallet\r\n     * @return donationAmount Amount going to donation wallet\r\n     */\r\n    function calculateDistribution(uint256 taxAmount)\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 feeAmount,\r\n            uint256 burnAmount,\r\n            uint256 donationAmount\r\n        )\r\n    {\r\n        feeAmount = (taxAmount * FEE_SHARE) / TAX_DENOMINATOR;\r\n        burnAmount = (taxAmount * BURN_SHARE) / TAX_DENOMINATOR;\r\n        donationAmount = taxAmount - feeAmount - burnAmount; // Ensures no rounding errors\r\n    }\r\n\r\n    /**\r\n     * @dev Determine if tax should be applied to a transfer\r\n     * @param data Tax data storage reference\r\n     * @param from Sender address\r\n     * @param to Recipient address\r\n     * @param isFromExempt Whether sender is exempt from tax\r\n     * @param isToExempt Whether recipient is exempt from tax\r\n     * @return shouldApply Whether tax should be applied\r\n     */\r\n    function shouldApplyTax(\r\n        TaxData storage data,\r\n        address from,\r\n        address to,\r\n        bool isFromExempt,\r\n        bool isToExempt\r\n    ) external view returns (bool shouldApply) {\r\n        // Tax only applies when trading is enabled\r\n        if (!data.tradingEnabled) {\r\n            return false;\r\n        }\r\n        \r\n        // No tax if either party is exempt\r\n        if (isFromExempt || isToExempt) {\r\n            return false;\r\n        }\r\n        \r\n        // Tax applies only for AMM pair transactions (buy/sell)\r\n        return (data.isAMMPair[from] || data.isAMMPair[to]);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate trading conditions for a transfer\r\n     * @param data Tax data storage reference\r\n     * @param from Sender address\r\n     * @param to Recipient address\r\n     * @param isFromExempt Whether sender is exempt from tax\r\n     * @param isToExempt Whether recipient is exempt from tax\r\n     */\r\n    function validateTrading(\r\n        TaxData storage data,\r\n        address from,\r\n        address to,\r\n        bool isFromExempt,\r\n        bool isToExempt\r\n    ) external view {\r\n        if (!data.tradingEnabled) {\r\n            require(isFromExempt || isToExempt, \"Trading not enabled\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Process tax distribution and emit events\r\n     * @param from Sender address (for transfer execution)\r\n     * @param taxAmount Total tax amount\r\n     * @param feeWallet Fee wallet address\r\n     * @param donationWallet Donation wallet address\r\n     * @return feeAmount Amount distributed to fee wallet\r\n     * @return burnAmount Amount distributed to burn wallet\r\n     * @return donationAmount Amount distributed to donation wallet\r\n     */\r\n    function distributeTax(\r\n        address from,\r\n        uint256 taxAmount,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external returns (\r\n        uint256 feeAmount,\r\n        uint256 burnAmount,\r\n        uint256 donationAmount\r\n    ) {\r\n        feeAmount = (taxAmount * FEE_SHARE) / TAX_DENOMINATOR;\r\n        burnAmount = (taxAmount * BURN_SHARE) / TAX_DENOMINATOR;\r\n        donationAmount = taxAmount - feeAmount - burnAmount; // Ensures no rounding errors\r\n        \r\n        // Note: Actual transfers are handled by the main contract\r\n        // This function only calculates and emits events\r\n        \r\n        emit TaxDistributed(feeAmount, burnAmount, donationAmount);\r\n        \r\n        return (feeAmount, burnAmount, donationAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Log transfer analytics for AMM transactions\r\n     * @param data Tax data storage reference\r\n     * @param from Sender address\r\n     * @param to Recipient address\r\n     * @param amount Transfer amount\r\n     */\r\n    function logTransferAnalytics(\r\n        TaxData storage data,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external {\r\n        if (data.isAMMPair[from] || data.isAMMPair[to]) {\r\n            address user = data.isAMMPair[from] ? to : from;\r\n            emit TransferAnalytics(user, amount, block.timestamp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get tax information\r\n     * @return buyTax Tax rate for buy transactions\r\n     * @return sellTax Tax rate for sell transactions\r\n     */\r\n    function getTaxInfo() external pure returns (uint256 buyTax, uint256 sellTax) {\r\n        return (TAX_RATE, TAX_RATE);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address is an AMM pair\r\n     * @param data Tax data storage reference\r\n     * @param pair Address to check\r\n     * @return isAMM Whether the address is an AMM pair\r\n     */\r\n    function isAMMPair(TaxData storage data, address pair) external view returns (bool) {\r\n        return data.isAMMPair[pair];\r\n    }\r\n\r\n    /**\r\n     * @dev Check if trading is enabled\r\n     * @param data Tax data storage reference\r\n     * @return enabled Whether trading is enabled\r\n     */\r\n    function isTradingEnabled(TaxData storage data) external view returns (bool) {\r\n        return data.tradingEnabled;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate effective transfer amount after tax\r\n     * @param amount Original transfer amount\r\n     * @param shouldTax Whether tax should be applied\r\n     * @return transferAmount Amount to transfer to recipient\r\n     * @return taxAmount Tax amount to be distributed\r\n     */\r\n    function calculateTransferAmounts(uint256 amount, bool shouldTax)\r\n        external\r\n        pure\r\n        returns (uint256 transferAmount, uint256 taxAmount)\r\n    {\r\n        if (shouldTax && amount > 0) {\r\n            taxAmount = (amount * TAX_RATE) / TAX_DENOMINATOR;\r\n            transferAmount = amount - taxAmount;\r\n        } else {\r\n            transferAmount = amount;\r\n            taxAmount = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validate AMM pair setting parameters\r\n     * @param pair Address to validate\r\n     * @param owner Contract owner address\r\n     * @param feeWallet Fee wallet address\r\n     * @param donationWallet Donation wallet address\r\n     */\r\n    function validateAMMPairSetting(\r\n        address pair,\r\n        address owner,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external pure {\r\n        require(pair != address(0), \"Invalid pair address\");\r\n        require(pair != owner, \"Cannot set owner as AMM pair\");\r\n        require(pair != feeWallet, \"Cannot set fee wallet as AMM pair\");\r\n        require(pair != donationWallet, \"Cannot set donation wallet as AMM pair\");\r\n        require(pair != BURN_WALLET, \"Cannot set burn wallet as AMM pair\");\r\n    }\r\n\r\n    /**\r\n     * @dev Get comprehensive tax status for an address pair\r\n     * @param data Tax data storage reference\r\n     * @param from Sender address\r\n     * @param to Recipient address\r\n     * @param isFromExempt Whether sender is exempt\r\n     * @param isToExempt Whether recipient is exempt\r\n     * @return willApplyTax Whether tax will be applied\r\n     * @return isFromAMM Whether sender is AMM pair\r\n     * @return isToAMM Whether recipient is AMM pair\r\n     * @return tradingActive Whether trading is enabled\r\n     */\r\n    function getTaxStatus(\r\n        TaxData storage data,\r\n        address from,\r\n        address to,\r\n        bool isFromExempt,\r\n        bool isToExempt\r\n    ) external view returns (\r\n        bool willApplyTax,\r\n        bool isFromAMM,\r\n        bool isToAMM,\r\n        bool tradingActive\r\n    ) {\r\n        isFromAMM = data.isAMMPair[from];\r\n        isToAMM = data.isAMMPair[to];\r\n        tradingActive = data.tradingEnabled;\r\n        \r\n        // Inline shouldApplyTax logic\r\n        if (!data.tradingEnabled) {\r\n            willApplyTax = false;\r\n        } else if (isFromExempt || isToExempt) {\r\n            willApplyTax = false;\r\n        } else {\r\n            willApplyTax = (data.isAMMPair[from] || data.isAMMPair[to]);\r\n        }\r\n    }\r\n}"
    },
    "contracts/libraries/WalletManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/**\r\n * @title WalletManager\r\n * @dev Library for managing wallet addresses with validation and tax exemption handling\r\n * @notice This library provides secure wallet management with proper validation and cooldown controls\r\n */\r\nlibrary WalletManager {\r\n    \r\n    // Constants\r\n    address public constant BURN_WALLET = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    /**\r\n     * @dev Wallet data structure for managing wallet addresses and exemptions\r\n     */\r\n    struct WalletData {\r\n        address feeWallet;                           // Address receiving fee portion of tax\r\n        address donationWallet;                      // Address receiving donation portion of tax\r\n        mapping(address => bool) isExemptFromTax;    // Tax exemption mapping\r\n        mapping(bytes4 => uint256) lastAdminAction;  // Cooldown tracking for admin actions\r\n    }\r\n\r\n    // Events\r\n    event FeeWalletUpdated(address indexed oldWallet, address indexed newWallet);\r\n    event DonationWalletUpdated(address indexed oldWallet, address indexed newWallet);\r\n    event BatchWalletUpdate(\r\n        address indexed oldFeeWallet, \r\n        address indexed newFeeWallet, \r\n        address indexed oldDonationWallet, \r\n        address newDonationWallet\r\n    );\r\n    event TaxExemptionUpdated(address indexed account, bool isExempt);\r\n\r\n    /**\r\n     * @dev Initialize wallet data with initial addresses\r\n     * @param data Wallet data storage reference\r\n     * @param _feeWallet Initial fee wallet address\r\n     * @param _donationWallet Initial donation wallet address\r\n     * @param _owner Contract owner address\r\n     * @param _contractAddress Contract address\r\n     * @param _initialExemptAccounts Array of initially exempt accounts\r\n     */\r\n    function initializeWallets(\r\n        WalletData storage data,\r\n        address _feeWallet,\r\n        address _donationWallet,\r\n        address _owner,\r\n        address _contractAddress,\r\n        address[] memory _initialExemptAccounts\r\n    ) external {\r\n        // Validate initial wallet addresses\r\n        validateWalletPair(_feeWallet, _donationWallet, _contractAddress);\r\n        \r\n        // Set wallet addresses\r\n        data.feeWallet = _feeWallet;\r\n        data.donationWallet = _donationWallet;\r\n        \r\n        // Set initial tax exemptions\r\n        data.isExemptFromTax[_owner] = true;\r\n        data.isExemptFromTax[_contractAddress] = true;\r\n        data.isExemptFromTax[_feeWallet] = true;\r\n        data.isExemptFromTax[_donationWallet] = true;\r\n        data.isExemptFromTax[BURN_WALLET] = true;\r\n        \r\n        // Set additional exempt accounts\r\n        for (uint256 i = 0; i < _initialExemptAccounts.length; i++) {\r\n            if (_initialExemptAccounts[i] != address(0)) {\r\n                data.isExemptFromTax[_initialExemptAccounts[i]] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update fee wallet address with validation\r\n     * @param data Wallet data storage reference\r\n     * @param newFeeWallet New fee wallet address\r\n     * @param owner Contract owner address\r\n     * @param contractAddress Contract address\r\n     */\r\n    function updateFeeWallet(\r\n        WalletData storage data,\r\n        address newFeeWallet,\r\n        address owner,\r\n        address contractAddress\r\n    ) external {\r\n        // Validate new wallet\r\n        validateSingleWallet(newFeeWallet, contractAddress);\r\n        require(newFeeWallet != data.feeWallet, \"Same as current fee wallet\");\r\n        require(newFeeWallet != data.donationWallet, \"Cannot be same as donation wallet\");\r\n        require(newFeeWallet != BURN_WALLET, \"Cannot be burn wallet\");\r\n        \r\n        address oldWallet = data.feeWallet;\r\n        \r\n        // Remove tax exemption from old wallet (if it's not a critical address)\r\n        if (oldWallet != owner && \r\n            oldWallet != contractAddress && \r\n            oldWallet != data.donationWallet) {\r\n            data.isExemptFromTax[oldWallet] = false;\r\n        }\r\n        \r\n        // Update wallet and set exemption\r\n        data.feeWallet = newFeeWallet;\r\n        data.isExemptFromTax[newFeeWallet] = true;\r\n        \r\n        emit FeeWalletUpdated(oldWallet, newFeeWallet);\r\n    }\r\n\r\n    /**\r\n     * @dev Update donation wallet address with validation\r\n     * @param data Wallet data storage reference\r\n     * @param newDonationWallet New donation wallet address\r\n     * @param owner Contract owner address\r\n     * @param contractAddress Contract address\r\n     */\r\n    function updateDonationWallet(\r\n        WalletData storage data,\r\n        address newDonationWallet,\r\n        address owner,\r\n        address contractAddress\r\n    ) external {\r\n        // Validate new wallet\r\n        validateSingleWallet(newDonationWallet, contractAddress);\r\n        require(newDonationWallet != data.donationWallet, \"Same as current donation wallet\");\r\n        require(newDonationWallet != data.feeWallet, \"Cannot be same as fee wallet\");\r\n        require(newDonationWallet != BURN_WALLET, \"Cannot be burn wallet\");\r\n        \r\n        address oldWallet = data.donationWallet;\r\n        \r\n        // Remove tax exemption from old wallet (if it's not a critical address)\r\n        if (oldWallet != owner && \r\n            oldWallet != contractAddress && \r\n            oldWallet != data.feeWallet) {\r\n            data.isExemptFromTax[oldWallet] = false;\r\n        }\r\n        \r\n        // Update wallet and set exemption\r\n        data.donationWallet = newDonationWallet;\r\n        data.isExemptFromTax[newDonationWallet] = true;\r\n        \r\n        emit DonationWalletUpdated(oldWallet, newDonationWallet);\r\n    }\r\n\r\n    /**\r\n     * @dev Update both wallets simultaneously with validation\r\n     * @param data Wallet data storage reference\r\n     * @param newFeeWallet New fee wallet address\r\n     * @param newDonationWallet New donation wallet address\r\n     * @param owner Contract owner address\r\n     * @param contractAddress Contract address\r\n     */\r\n    function updateBothWallets(\r\n        WalletData storage data,\r\n        address newFeeWallet,\r\n        address newDonationWallet,\r\n        address owner,\r\n        address contractAddress\r\n    ) external {\r\n        // Validate both wallets\r\n        validateWalletPair(newFeeWallet, newDonationWallet, contractAddress);\r\n        \r\n        // Store old addresses\r\n        address oldFeeWallet = data.feeWallet;\r\n        address oldDonationWallet = data.donationWallet;\r\n        \r\n        // Remove tax exemption from old wallets (if they're not critical addresses)\r\n        if (oldFeeWallet != owner && \r\n            oldFeeWallet != contractAddress && \r\n            oldFeeWallet != newDonationWallet) {\r\n            data.isExemptFromTax[oldFeeWallet] = false;\r\n        }\r\n        \r\n        if (oldDonationWallet != owner && \r\n            oldDonationWallet != contractAddress && \r\n            oldDonationWallet != newFeeWallet) {\r\n            data.isExemptFromTax[oldDonationWallet] = false;\r\n        }\r\n        \r\n        // Update wallets\r\n        data.feeWallet = newFeeWallet;\r\n        data.donationWallet = newDonationWallet;\r\n        \r\n        // Set tax exemptions for new wallets\r\n        data.isExemptFromTax[newFeeWallet] = true;\r\n        data.isExemptFromTax[newDonationWallet] = true;\r\n        \r\n        // Emit events\r\n        emit BatchWalletUpdate(oldFeeWallet, newFeeWallet, oldDonationWallet, newDonationWallet);\r\n        emit FeeWalletUpdated(oldFeeWallet, newFeeWallet);\r\n        emit DonationWalletUpdated(oldDonationWallet, newDonationWallet);\r\n    }\r\n\r\n    /**\r\n     * @dev Update tax exemption status for an account\r\n     * @param data Wallet data storage reference\r\n     * @param account Account to update exemption for\r\n     * @param isExempt New exemption status\r\n     * @param owner Contract owner address\r\n     * @param contractAddress Contract address\r\n     */\r\n    function updateTaxExemption(\r\n        WalletData storage data,\r\n        address account,\r\n        bool isExempt,\r\n        address owner,\r\n        address contractAddress\r\n    ) external {\r\n        require(account != address(0), \"Invalid account address\");\r\n        \r\n        // Prevent removing exemption from critical addresses\r\n        if (!isExempt) {\r\n            require(account != contractAddress, \"Contract must remain tax exempt\");\r\n            require(account != owner, \"Owner must remain tax exempt\");\r\n            require(account != data.feeWallet, \"Fee wallet must remain tax exempt\");\r\n            require(account != data.donationWallet, \"Donation wallet must remain tax exempt\");\r\n            require(account != BURN_WALLET, \"Burn wallet must remain tax exempt\");\r\n        }\r\n        \r\n        data.isExemptFromTax[account] = isExempt;\r\n        emit TaxExemptionUpdated(account, isExempt);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate a single wallet address\r\n     * @param wallet Wallet address to validate\r\n     * @param contractAddress Contract address to check against\r\n     */\r\n    function validateSingleWallet(address wallet, address contractAddress) public pure {\r\n        require(wallet != address(0), \"Invalid wallet address\");\r\n        require(wallet != contractAddress, \"Cannot be contract address\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validate a pair of wallet addresses\r\n     * @param feeWallet Fee wallet address\r\n     * @param donationWallet Donation wallet address\r\n     * @param contractAddress Contract address to check against\r\n     */\r\n    function validateWalletPair(\r\n        address feeWallet,\r\n        address donationWallet,\r\n        address contractAddress\r\n    ) public pure {\r\n        validateSingleWallet(feeWallet, contractAddress);\r\n        validateSingleWallet(donationWallet, contractAddress);\r\n        require(feeWallet != donationWallet, \"Wallets cannot be the same\");\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address is exempt from tax\r\n     * @param data Wallet data storage reference\r\n     * @param account Account to check\r\n     * @return isExempt Whether the account is exempt from tax\r\n     */\r\n    function isExemptFromTax(WalletData storage data, address account) \r\n        external \r\n        view \r\n        returns (bool) \r\n    {\r\n        return data.isExemptFromTax[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Get current wallet addresses\r\n     * @param data Wallet data storage reference\r\n     * @return feeWallet Current fee wallet address\r\n     * @return donationWallet Current donation wallet address\r\n     */\r\n    function getWallets(WalletData storage data) \r\n        external \r\n        view \r\n        returns (address feeWallet, address donationWallet) \r\n    {\r\n        return (data.feeWallet, data.donationWallet);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate wallet for AMM pair setting\r\n     * @param data Wallet data storage reference\r\n     * @param pair Address to validate\r\n     * @param owner Contract owner address\r\n     */\r\n    function validateAMMPairWallet(\r\n        WalletData storage data,\r\n        address pair,\r\n        address owner\r\n    ) external view {\r\n        require(pair != owner, \"Cannot set owner as AMM pair\");\r\n        require(pair != data.feeWallet, \"Cannot set fee wallet as AMM pair\");\r\n        require(pair != data.donationWallet, \"Cannot set donation wallet as AMM pair\");\r\n        require(pair != BURN_WALLET, \"Cannot set burn wallet as AMM pair\");\r\n    }\r\n}"
    },
    "contracts/mocks/AccessControlTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"../libraries/AccessControl.sol\";\r\n\r\n/**\r\n * @title AccessControlTestContract\r\n * @dev Test contract for AccessControl library functions\r\n * @notice Pause mechanism removed - SafeWallet multisig handles governance\r\n */\r\ncontract AccessControlTestContract {\r\n    using AccessControlLib for AccessControlLib.AccessData;\r\n    \r\n    AccessControlLib.AccessData private accessData;\r\n    address public owner;\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    // Test functions for AccessControl library\r\n    \r\n    function testCheckOwnerWithCooldown(bytes4 functionSig) external {\r\n        accessData.checkOwnerWithCooldown(functionSig, msg.sender, owner);\r\n    }\r\n    \r\n    function testRequirePendingOwner() external view {\r\n        accessData.requirePendingOwner(msg.sender);\r\n    }\r\n    \r\n    function testInitiateOwnershipTransfer(address newOwner) external onlyOwner {\r\n        accessData.initiateOwnershipTransfer(newOwner, owner);\r\n    }\r\n    \r\n    function testCompleteOwnershipTransfer() external returns (address previousOwner, address newOwner) {\r\n        (previousOwner, newOwner) = accessData.completeOwnershipTransfer(msg.sender);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function testCancelOwnershipTransfer() external onlyOwner {\r\n        accessData.cancelOwnershipTransfer(owner);\r\n    }\r\n    \r\n    function testGetOwnershipTransferStatus() external view returns (\r\n        bool isPending,\r\n        address pendingOwner,\r\n        uint256 initiatedAt,\r\n        bool canComplete\r\n    ) {\r\n        return accessData.getOwnershipTransferStatus();\r\n    }\r\n    \r\n    function testGetLastAdminAction(bytes4 functionSig) external view returns (uint256) {\r\n        return accessData.getLastAdminAction(functionSig);\r\n    }\r\n    \r\n    function testCheckCooldown(bytes4 functionSig) external view returns (bool canExecute, uint256 timeRemaining) {\r\n        return accessData.checkCooldown(functionSig);\r\n    }\r\n    \r\n    function testValidateOwnershipTransfer(address newOwner, address currentOwner, address contractAddress) external pure {\r\n        AccessControlLib.validateOwnershipTransfer(newOwner, currentOwner, contractAddress);\r\n    }\r\n    \r\n    // Helper functions for testing\r\n    function getCurrentOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n    \r\n    function setOwner(address newOwner) external {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    // Get constants for testing\r\n    function getAdminCooldown() external pure returns (uint256) {\r\n        return AccessControlLib.ADMIN_COOLDOWN;\r\n    }\r\n    \r\n    function getOwnershipTimelock() external pure returns (uint256) {\r\n        return AccessControlLib.OWNERSHIP_TIMELOCK;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/EmergencyManagerLibraryTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"../libraries/EmergencyManager.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title EmergencyManagerLibraryTestContract\r\n * @dev Test contract for EmergencyManager library functions\r\n */\r\ncontract EmergencyManagerLibraryTestContract {\r\n    using EmergencyManager for EmergencyManager.EmergencyData;\r\n    \r\n    EmergencyManager.EmergencyData private emergencyData;\r\n    \r\n    // Expose constants for testing\r\n    function getEmergencyTimelock() external pure returns (uint256) {\r\n        return EmergencyManager.EMERGENCY_TIMELOCK;\r\n    }\r\n    \r\n    function getEmergencyWindow() external pure returns (uint256) {\r\n        return EmergencyManager.EMERGENCY_WINDOW;\r\n    }\r\n    \r\n    // Test functions for EmergencyManager library\r\n    function testEnableEmergencyWithdraw() external {\r\n        EmergencyManager.enableEmergencyWithdraw(emergencyData);\r\n    }\r\n    \r\n    function testCancelEmergencyWithdraw() external {\r\n        EmergencyManager.cancelEmergencyWithdraw(emergencyData);\r\n    }\r\n    \r\n    function testExecuteEmergencyWithdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address payable recipient\r\n    ) external {\r\n        EmergencyManager.executeEmergencyWithdraw(emergencyData, token, amount, recipient);\r\n    }\r\n    \r\n    function testGetEmergencyStatus() external view returns (\r\n        bool isEnabled,\r\n        uint256 unlockTime,\r\n        bool canWithdraw,\r\n        bool hasExpired\r\n    ) {\r\n        return EmergencyManager.getEmergencyStatus(emergencyData);\r\n    }\r\n    \r\n    function testGetEmergencyStats(address token) external view returns (\r\n        uint256 withdrawnAmount,\r\n        uint256 totalWithdrawn,\r\n        uint256 contractBalance\r\n    ) {\r\n        return EmergencyManager.getEmergencyStats(emergencyData, token);\r\n    }\r\n    \r\n    function testValidateEmergencyWithdraw(\r\n        address token,\r\n        uint256 amount\r\n    ) external view returns (bool isValid, string memory errorMessage) {\r\n        return EmergencyManager.validateEmergencyWithdraw(emergencyData, token, amount);\r\n    }\r\n    \r\n    // Helper functions for testing\r\n    receive() external payable {}\r\n    \r\n    function getBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    function getTokenBalance(address token) external view returns (uint256) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n}"
    },
    "contracts/mocks/EmergencyManagerTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title EmergencyManagerTestContract\r\n * @dev Test contract that implements EmergencyManager library functionality for testing\r\n */\r\ncontract EmergencyManagerTestContract {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Constants from EmergencyManager library\r\n    uint256 public constant EMERGENCY_TIMELOCK = 2 days;\r\n    uint256 public constant EMERGENCY_WINDOW = 1 hours;\r\n\r\n    // Emergency data structure\r\n    struct EmergencyData {\r\n        uint256 unlockTime;\r\n        mapping(address => uint256) withdrawHistory;\r\n        uint256 totalWithdrawn;\r\n    }\r\n\r\n    EmergencyData private emergencyData;\r\n\r\n    // Events\r\n    event EmergencyWithdrawEnabled(uint256 unlockTime);\r\n    event EmergencyWithdrawCancelled();\r\n    event EmergencyWithdraw(address indexed token, uint256 amount);\r\n    event EmergencyWithdrawHistoryUpdated(address indexed token, uint256 amount, uint256 totalWithdrawn);\r\n\r\n    // Test functions that implement library functionality\r\n    function testEnableEmergencyWithdraw() external {\r\n        require(emergencyData.unlockTime == 0, \"Emergency withdraw already enabled\");\r\n        \r\n        emergencyData.unlockTime = block.timestamp + EMERGENCY_TIMELOCK;\r\n        \r\n        emit EmergencyWithdrawEnabled(emergencyData.unlockTime);\r\n    }\r\n\r\n    function testCancelEmergencyWithdraw() external {\r\n        require(emergencyData.unlockTime != 0, \"Emergency withdraw not enabled\");\r\n        require(block.timestamp < emergencyData.unlockTime, \"Emergency withdraw timelock already passed\");\r\n        \r\n        emergencyData.unlockTime = 0;\r\n        emit EmergencyWithdrawCancelled();\r\n    }\r\n\r\n    function testExecuteEmergencyWithdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address payable recipient\r\n    ) external {\r\n        // Validate timelock conditions\r\n        require(emergencyData.unlockTime != 0 && block.timestamp >= emergencyData.unlockTime, \r\n            \"Emergency withdraw timelock not passed\");\r\n        require(block.timestamp <= emergencyData.unlockTime + EMERGENCY_WINDOW,\r\n            \"Emergency withdraw window expired\");\r\n        \r\n        // Validate inputs\r\n        require(amount > 0, \"Amount must be greater than zero\");\r\n        require(recipient != address(0), \"Invalid recipient address\");\r\n        \r\n        // Check balance and execute withdrawal\r\n        if (token == address(0)) {\r\n            // ETH withdrawal\r\n            require(address(this).balance >= amount, \"Insufficient ETH balance\");\r\n            recipient.transfer(amount);\r\n        } else {\r\n            // ERC20 token withdrawal\r\n            IERC20 tokenContract = IERC20(token);\r\n            require(tokenContract.balanceOf(address(this)) >= amount, \"Insufficient token balance\");\r\n            tokenContract.safeTransfer(recipient, amount);\r\n        }\r\n        \r\n        // Update history and reset state\r\n        emergencyData.withdrawHistory[token] += amount;\r\n        emergencyData.totalWithdrawn += amount;\r\n        emergencyData.unlockTime = 0; // Reset timelock after successful withdrawal\r\n        \r\n        emit EmergencyWithdraw(token, amount);\r\n        emit EmergencyWithdrawHistoryUpdated(token, amount, emergencyData.withdrawHistory[token]);\r\n    }\r\n\r\n    function testGetEmergencyStatus() external view returns (\r\n        bool isEnabled,\r\n        uint256 unlockTime,\r\n        bool canWithdraw,\r\n        bool hasExpired\r\n    ) {\r\n        isEnabled = emergencyData.unlockTime != 0;\r\n        unlockTime = emergencyData.unlockTime;\r\n        \r\n        if (isEnabled) {\r\n            canWithdraw = block.timestamp >= emergencyData.unlockTime && \r\n                         block.timestamp <= emergencyData.unlockTime + EMERGENCY_WINDOW;\r\n            hasExpired = block.timestamp > emergencyData.unlockTime + EMERGENCY_WINDOW;\r\n        } else {\r\n            canWithdraw = false;\r\n            hasExpired = false;\r\n        }\r\n    }\r\n\r\n    function testGetEmergencyStats(address token) external view returns (\r\n        uint256 withdrawnAmount,\r\n        uint256 totalWithdrawn,\r\n        uint256 contractBalance\r\n    ) {\r\n        withdrawnAmount = emergencyData.withdrawHistory[token];\r\n        totalWithdrawn = emergencyData.totalWithdrawn;\r\n        \r\n        if (token == address(0)) {\r\n            contractBalance = address(this).balance;\r\n        } else {\r\n            contractBalance = IERC20(token).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function testValidateEmergencyWithdraw(\r\n        address token,\r\n        uint256 amount\r\n    ) external view returns (bool isValid, string memory errorMessage) {\r\n        // Check timelock conditions\r\n        if (emergencyData.unlockTime == 0) {\r\n            return (false, \"Emergency withdraw not enabled\");\r\n        }\r\n        \r\n        if (block.timestamp < emergencyData.unlockTime) {\r\n            return (false, \"Emergency withdraw timelock not passed\");\r\n        }\r\n        \r\n        if (block.timestamp > emergencyData.unlockTime + EMERGENCY_WINDOW) {\r\n            return (false, \"Emergency withdraw window expired\");\r\n        }\r\n        \r\n        // Check amount\r\n        if (amount == 0) {\r\n            return (false, \"Amount must be greater than zero\");\r\n        }\r\n        \r\n        // Check balance\r\n        uint256 balance;\r\n        if (token == address(0)) {\r\n            balance = address(this).balance;\r\n        } else {\r\n            balance = IERC20(token).balanceOf(address(this));\r\n        }\r\n        \r\n        if (balance < amount) {\r\n            return (false, \"Insufficient balance\");\r\n        }\r\n        \r\n        return (true, \"\");\r\n    }\r\n\r\n    // Helper functions for testing\r\n    function getEmergencyTimelock() external pure returns (uint256) {\r\n        return EMERGENCY_TIMELOCK;\r\n    }\r\n    \r\n    function getEmergencyWindow() external pure returns (uint256) {\r\n        return EMERGENCY_WINDOW;\r\n    }\r\n    \r\n    // Function to receive ETH for testing\r\n    receive() external payable {}\r\n    \r\n    // Function to check contract ETH balance\r\n    function getETHBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    // Function to check token balance\r\n    function getTokenBalance(address token) external view returns (uint256) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n}"
    },
    "contracts/mocks/EnhancedTestAMM.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\ncontract EnhancedTestAMM is ReentrancyGuard {\r\n    IERC20 public token;\r\n    uint256 public constant FEE_RATE = 30; // 0.3%\r\n    uint256 public constant FEE_DENOMINATOR = 10000;\r\n    \r\n    mapping(address => uint256) public liquidityProviders;\r\n    uint256 public totalLiquidity;\r\n    uint256 public ethReserve;\r\n    uint256 public tokenReserve;\r\n    \r\n    event LiquidityAdded(address indexed provider, uint256 ethAmount, uint256 tokenAmount);\r\n    event LiquidityRemoved(address indexed provider, uint256 ethAmount, uint256 tokenAmount);\r\n    event Swap(address indexed user, uint256 ethIn, uint256 tokenOut, uint256 tokenIn, uint256 ethOut);\r\n    \r\n    constructor() {\r\n        // No token set initially - can be set later\r\n    }\r\n    \r\n    function setToken(address _token) external {\r\n        require(address(token) == address(0), \"Token already set\");\r\n        token = IERC20(_token);\r\n    }\r\n    \r\n    function addLiquidity(uint256 tokenAmount) external payable nonReentrant {\r\n        require(msg.value > 0, \"Must send ETH\");\r\n        require(tokenAmount > 0, \"Must send tokens\");\r\n        require(address(token) != address(0), \"Token not set\");\r\n        \r\n        require(token.transferFrom(msg.sender, address(this), tokenAmount), \"Token transfer failed\");\r\n        \r\n        liquidityProviders[msg.sender] += msg.value;\r\n        totalLiquidity += msg.value;\r\n        ethReserve += msg.value;\r\n        tokenReserve += tokenAmount;\r\n        \r\n        emit LiquidityAdded(msg.sender, msg.value, tokenAmount);\r\n    }\r\n    \r\n    function removeLiquidity(uint256 ethAmount) external nonReentrant {\r\n        require(liquidityProviders[msg.sender] >= ethAmount, \"Insufficient liquidity\");\r\n        require(ethReserve >= ethAmount, \"Insufficient ETH reserve\");\r\n        \r\n        uint256 tokenAmount = (tokenReserve * ethAmount) / ethReserve;\r\n        \r\n        liquidityProviders[msg.sender] -= ethAmount;\r\n        totalLiquidity -= ethAmount;\r\n        ethReserve -= ethAmount;\r\n        tokenReserve -= tokenAmount;\r\n        \r\n        require(token.transfer(msg.sender, tokenAmount), \"Token transfer failed\");\r\n        payable(msg.sender).transfer(ethAmount);\r\n        \r\n        emit LiquidityRemoved(msg.sender, ethAmount, tokenAmount);\r\n    }\r\n    \r\n    function swapETHForTokens() external payable nonReentrant {\r\n        require(msg.value > 0, \"Must send ETH\");\r\n        require(tokenReserve > 0, \"No token liquidity\");\r\n        \r\n        uint256 fee = (msg.value * FEE_RATE) / FEE_DENOMINATOR;\r\n        uint256 ethAfterFee = msg.value - fee;\r\n        \r\n        // Simple AMM formula: tokenOut = (tokenReserve * ethAfterFee) / (ethReserve + ethAfterFee)\r\n        uint256 tokenOut = (tokenReserve * ethAfterFee) / (ethReserve + ethAfterFee);\r\n        \r\n        require(tokenOut > 0, \"Insufficient output amount\");\r\n        require(tokenReserve >= tokenOut, \"Insufficient token reserve\");\r\n        \r\n        ethReserve += msg.value;\r\n        tokenReserve -= tokenOut;\r\n        \r\n        require(token.transfer(msg.sender, tokenOut), \"Token transfer failed\");\r\n        \r\n        emit Swap(msg.sender, msg.value, tokenOut, 0, 0);\r\n    }\r\n    \r\n    function swapTokensForETH(uint256 tokenAmount) external nonReentrant {\r\n        require(tokenAmount > 0, \"Must send tokens\");\r\n        require(ethReserve > 0, \"No ETH liquidity\");\r\n        \r\n        require(token.transferFrom(msg.sender, address(this), tokenAmount), \"Token transfer failed\");\r\n        \r\n        uint256 fee = (tokenAmount * FEE_RATE) / FEE_DENOMINATOR;\r\n        uint256 tokenAfterFee = tokenAmount - fee;\r\n        \r\n        // Simple AMM formula: ethOut = (ethReserve * tokenAfterFee) / (tokenReserve + tokenAfterFee)\r\n        uint256 ethOut = (ethReserve * tokenAfterFee) / (tokenReserve + tokenAfterFee);\r\n        \r\n        require(ethOut > 0, \"Insufficient output amount\");\r\n        require(ethReserve >= ethOut, \"Insufficient ETH reserve\");\r\n        \r\n        tokenReserve += tokenAmount;\r\n        ethReserve -= ethOut;\r\n        \r\n        payable(msg.sender).transfer(ethOut);\r\n        \r\n        emit Swap(msg.sender, 0, 0, tokenAmount, ethOut);\r\n    }\r\n    \r\n    function getReserves() external view returns (uint256 _ethReserve, uint256 _tokenReserve) {\r\n        return (ethReserve, tokenReserve);\r\n    }\r\n    \r\n    function getAmountOut(uint256 amountIn, bool ethToToken) external view returns (uint256) {\r\n        if (ethToToken) {\r\n            if (tokenReserve == 0) return 0;\r\n            uint256 fee = (amountIn * FEE_RATE) / FEE_DENOMINATOR;\r\n            uint256 amountAfterFee = amountIn - fee;\r\n            return (tokenReserve * amountAfterFee) / (ethReserve + amountAfterFee);\r\n        } else {\r\n            if (ethReserve == 0) return 0;\r\n            uint256 fee = (amountIn * FEE_RATE) / FEE_DENOMINATOR;\r\n            uint256 amountAfterFee = amountIn - fee;\r\n            return (ethReserve * amountAfterFee) / (tokenReserve + amountAfterFee);\r\n        }\r\n    }\r\n    \r\n    function getAddress() external view returns (address) {\r\n        return address(this);\r\n    }\r\n    \r\n    // Emergency functions\r\n    function emergencyWithdraw() external {\r\n        require(msg.sender == address(0), \"Only zero address\"); // Impossible condition for testing\r\n    }\r\n    \r\n    receive() external payable {\r\n        // Accept ETH transfers\r\n    }\r\n}"
    },
    "contracts/mocks/InputValidatorTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"../libraries/InputValidator.sol\";\r\n\r\n/**\r\n * @title InputValidatorTestContract\r\n * @dev Test contract to expose InputValidator library functions for testing\r\n */\r\ncontract InputValidatorTestContract {\r\n    using InputValidator for *;\r\n\r\n    // Test wrapper functions for InputValidator library\r\n    function testValidateAddressWithMessage(address addr, string memory errorMessage) external pure {\r\n        InputValidator.validateAddressWithMessage(addr, errorMessage);\r\n    }\r\n\r\n    function testValidateAddress(address addr) external pure {\r\n        InputValidator.validateAddress(addr);\r\n    }\r\n\r\n    function testValidateNotContract(address addr, address contractAddress) external pure {\r\n        InputValidator.validateNotContract(addr, contractAddress);\r\n    }\r\n\r\n    function testValidateWalletPair(\r\n        address wallet1,\r\n        address wallet2,\r\n        address contractAddress\r\n    ) external pure {\r\n        InputValidator.validateWalletPair(wallet1, wallet2, contractAddress);\r\n    }\r\n\r\n    function testValidateAmount(uint256 amount) external pure {\r\n        InputValidator.validateAmount(amount);\r\n    }\r\n\r\n    function testValidateAmountWithMin(uint256 amount, uint256 minAmount) external pure {\r\n        InputValidator.validateAmountWithMin(amount, minAmount);\r\n    }\r\n\r\n    function testValidateTransferAddresses(address from, address to) external pure {\r\n        InputValidator.validateTransferAddresses(from, to);\r\n    }\r\n\r\n    function testValidateArrayLength(uint256 arrayLength) external pure {\r\n        InputValidator.validateArrayLength(arrayLength);\r\n    }\r\n\r\n    function testValidateArrayLengths(uint256 array1Length, uint256 array2Length) external pure {\r\n        InputValidator.validateArrayLengths(array1Length, array2Length);\r\n    }\r\n\r\n    function testValidateAddressArray(address[] memory addresses) external pure {\r\n        InputValidator.validateAddressArray(addresses);\r\n    }\r\n\r\n    function testValidateOwnershipTransfer(\r\n        address newOwner,\r\n        address currentOwner,\r\n        address contractAddress\r\n    ) external pure {\r\n        InputValidator.validateOwnershipTransfer(newOwner, currentOwner, contractAddress);\r\n    }\r\n\r\n    function testValidateWalletUpdate(\r\n        address newWallet,\r\n        address currentWallet,\r\n        address contractAddress\r\n    ) external pure {\r\n        InputValidator.validateWalletUpdate(newWallet, currentWallet, contractAddress);\r\n    }\r\n\r\n    function testValidateAMMPair(\r\n        address pair,\r\n        address contractAddress,\r\n        address owner,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external pure {\r\n        InputValidator.validateAMMPair(pair, contractAddress, owner, feeWallet, donationWallet);\r\n    }\r\n\r\n    function testValidateEmergencyWithdraw(\r\n        address token,\r\n        uint256 amount,\r\n        address recipient\r\n    ) external pure {\r\n        InputValidator.validateEmergencyWithdraw(token, amount, recipient);\r\n    }\r\n\r\n    function testValidateTaxExemption(\r\n        address account,\r\n        bool exempt,\r\n        address owner,\r\n        address contractAddress,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external pure {\r\n        InputValidator.validateTaxExemption(account, exempt, owner, contractAddress, feeWallet, donationWallet);\r\n    }\r\n\r\n    function testValidatePercentage(uint256 percentage, uint256 maxPercentage) external pure {\r\n        InputValidator.validatePercentage(percentage, maxPercentage);\r\n    }\r\n\r\n    function testValidateTimelock(\r\n        uint256 unlockTime,\r\n        uint256 currentTime,\r\n        uint256 minDelay\r\n    ) external pure {\r\n        InputValidator.validateTimelock(unlockTime, currentTime, minDelay);\r\n    }\r\n\r\n    function testValidateCooldown(\r\n        uint256 lastAction,\r\n        uint256 currentTime,\r\n        uint256 cooldownPeriod\r\n    ) external pure {\r\n        InputValidator.validateCooldown(lastAction, currentTime, cooldownPeriod);\r\n    }\r\n\r\n    function testValidateBalance(uint256 balance, uint256 amount) external pure {\r\n        InputValidator.validateBalance(balance, amount);\r\n    }\r\n\r\n    function testValidateContractState(\r\n        bool isPaused,\r\n        bool tradingEnabled,\r\n        bool requireTrading\r\n    ) external pure {\r\n        InputValidator.validateContractState(isPaused, tradingEnabled, requireTrading);\r\n    }\r\n\r\n    function testValidateConstructorParams(\r\n        address feeWallet,\r\n        address donationWallet,\r\n        address contractAddress,\r\n        address[] memory initialExemptAccounts\r\n    ) external pure {\r\n        InputValidator.validateConstructorParams(feeWallet, donationWallet, contractAddress, initialExemptAccounts);\r\n    }\r\n\r\n    // Helper function to get constants for testing\r\n    function getMaxArrayLength() external pure returns (uint256) {\r\n        return InputValidator.MAX_ARRAY_LENGTH;\r\n    }\r\n\r\n    function getMinTransferAmount() external pure returns (uint256) {\r\n        return InputValidator.MIN_TRANSFER_AMOUNT;\r\n    }\r\n}"
    },
    "contracts/mocks/MaliciousEmergencyContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title MaliciousEmergencyContract\r\n * @dev Contract to test unauthorized access and reentrancy attacks on EmergencyManager\r\n */\r\ncontract MaliciousEmergencyContract {\r\n    address public targetContract;\r\n    bool public reentrancyAttempted = false;\r\n    \r\n    constructor(address _targetContract) {\r\n        targetContract = _targetContract;\r\n    }\r\n    \r\n    // Attempt to call emergency functions without proper authorization\r\n    function attemptUnauthorizedEnable() external {\r\n        // Try to call the target contract's emergency enable function\r\n        (bool success,) = targetContract.call(\r\n            abi.encodeWithSignature(\"enableEmergencyWithdraw()\")\r\n        );\r\n        require(success, \"Unauthorized call failed\");\r\n    }\r\n    \r\n    function attemptUnauthorizedCancel() external {\r\n        // Try to call the target contract's emergency cancel function\r\n        (bool success,) = targetContract.call(\r\n            abi.encodeWithSignature(\"cancelEmergencyWithdraw()\")\r\n        );\r\n        require(success, \"Unauthorized call failed\");\r\n    }\r\n    \r\n    function attemptUnauthorizedWithdraw(address token, uint256 amount) external {\r\n        // Try to call the target contract's emergency withdraw function\r\n        (bool success,) = targetContract.call(\r\n            abi.encodeWithSignature(\"emergencyWithdraw(address,uint256)\", token, amount)\r\n        );\r\n        require(success, \"Unauthorized call failed\");\r\n    }\r\n    \r\n    // Reentrancy attack attempt\r\n    receive() external payable {\r\n        if (!reentrancyAttempted && address(this).balance > 0) {\r\n            reentrancyAttempted = true;\r\n            // Try to call emergency withdraw again during the transfer\r\n            try this.attemptReentrancy() {\r\n                // Reentrancy succeeded\r\n            } catch {\r\n                // Reentrancy failed (expected)\r\n            }\r\n        }\r\n    }\r\n    \r\n    function attemptReentrancy() external {\r\n        if (targetContract != address(0)) {\r\n            // Try to call the target contract's emergency function\r\n            (bool success,) = targetContract.call(\r\n                abi.encodeWithSignature(\"emergencyWithdraw(address,uint256)\", address(0), 1 ether)\r\n            );\r\n        }\r\n    }\r\n    \r\n    function resetReentrancyFlag() external {\r\n        reentrancyAttempted = false;\r\n    }\r\n}"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract MockERC20 is ERC20 {\r\n    uint8 private _decimals;\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals_\r\n    ) ERC20(name, symbol) {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function burn(address from, uint256 amount) public {\r\n        _burn(from, amount);\r\n    }\r\n}"
    },
    "contracts/mocks/NonStandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title NonStandardERC20\r\n * @dev Mock ERC20 token that doesn't return boolean values (like USDT)\r\n * Used for testing SafeERC20 compatibility\r\n */\r\ncontract NonStandardERC20 {\r\n    string public name = \"Non-Standard Token\";\r\n    string public symbol = \"NST\";\r\n    uint8 public decimals = 6; // Like USDT\r\n    uint256 public totalSupply = 1000000 * 10**6;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n    constructor() {\r\n        balanceOf[msg.sender] = totalSupply;\r\n    }\r\n    \r\n    // Non-standard: doesn't return boolean\r\n    function transfer(address to, uint256 amount) external {\r\n        require(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\r\n        require(to != address(0), \"Invalid recipient\");\r\n        \r\n        balanceOf[msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        \r\n        emit Transfer(msg.sender, to, amount);\r\n        // Note: No return value (like USDT)\r\n    }\r\n    \r\n    // Non-standard: doesn't return boolean\r\n    function transferFrom(address from, address to, uint256 amount) external {\r\n        require(balanceOf[from] >= amount, \"Insufficient balance\");\r\n        require(allowance[from][msg.sender] >= amount, \"Insufficient allowance\");\r\n        require(to != address(0), \"Invalid recipient\");\r\n        \r\n        balanceOf[from] -= amount;\r\n        balanceOf[to] += amount;\r\n        allowance[from][msg.sender] -= amount;\r\n        \r\n        emit Transfer(from, to, amount);\r\n        // Note: No return value (like USDT)\r\n    }\r\n    \r\n    // Non-standard: doesn't return boolean\r\n    function approve(address spender, uint256 amount) external {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        // Note: No return value (like USDT)\r\n    }\r\n    \r\n    // Helper function for testing\r\n    function mint(address to, uint256 amount) external {\r\n        balanceOf[to] += amount;\r\n        totalSupply += amount;\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n    \r\n    // Simulate transfer failure for testing\r\n    bool public shouldFailTransfer = false;\r\n    \r\n    function setShouldFailTransfer(bool _shouldFail) external {\r\n        shouldFailTransfer = _shouldFail;\r\n    }\r\n    \r\n    function failingTransfer(address to, uint256 amount) external {\r\n        require(!shouldFailTransfer, \"Transfer intentionally failed\");\r\n        require(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\r\n        require(to != address(0), \"Invalid recipient\");\r\n        \r\n        balanceOf[msg.sender] -= amount;\r\n        balanceOf[to] += amount;\r\n        \r\n        emit Transfer(msg.sender, to, amount);\r\n    }\r\n}"
    },
    "contracts/mocks/TaxManagerTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"../libraries/TaxManager.sol\";\r\n\r\n/**\r\n * @title TaxManagerTestContract\r\n * @dev Test contract for TaxManager library functions\r\n */\r\ncontract TaxManagerTestContract {\r\n    using TaxManager for TaxManager.TaxData;\r\n    \r\n    TaxManager.TaxData private taxData;\r\n    \r\n    // Expose constants for testing\r\n    function TAX_RATE() external pure returns (uint256) {\r\n        return TaxManager.TAX_RATE;\r\n    }\r\n    \r\n    function TAX_DENOMINATOR() external pure returns (uint256) {\r\n        return TaxManager.TAX_DENOMINATOR;\r\n    }\r\n    \r\n    function FEE_SHARE() external pure returns (uint256) {\r\n        return TaxManager.FEE_SHARE;\r\n    }\r\n    \r\n    function BURN_SHARE() external pure returns (uint256) {\r\n        return TaxManager.BURN_SHARE;\r\n    }\r\n    \r\n    function DONATION_SHARE() external pure returns (uint256) {\r\n        return TaxManager.DONATION_SHARE;\r\n    }\r\n    \r\n    function BURN_WALLET() external pure returns (address) {\r\n        return TaxManager.BURN_WALLET;\r\n    }\r\n    \r\n    // Test functions for TaxManager library\r\n    function testEnableTrading() external {\r\n        TaxManager.enableTrading(taxData);\r\n    }\r\n    \r\n    function testSetAMMPair(\r\n        address pair,\r\n        bool isPair,\r\n        address owner,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external {\r\n        TaxManager.setAMMPair(taxData, pair, isPair, owner, feeWallet, donationWallet);\r\n    }\r\n    \r\n    function testCalculateTaxAmount(uint256 amount) external pure returns (uint256) {\r\n        return TaxManager.calculateTaxAmount(amount);\r\n    }\r\n    \r\n    function testCalculateDistribution(uint256 taxAmount) external pure returns (\r\n        uint256 feeAmount,\r\n        uint256 burnAmount,\r\n        uint256 donationAmount\r\n    ) {\r\n        return TaxManager.calculateDistribution(taxAmount);\r\n    }\r\n    \r\n    function testShouldApplyTax(\r\n        address from,\r\n        address to,\r\n        bool isFromExempt,\r\n        bool isToExempt\r\n    ) external view returns (bool) {\r\n        return TaxManager.shouldApplyTax(taxData, from, to, isFromExempt, isToExempt);\r\n    }\r\n    \r\n    function testValidateTrading(\r\n        address from,\r\n        address to,\r\n        bool isFromExempt,\r\n        bool isToExempt\r\n    ) external view {\r\n        TaxManager.validateTrading(taxData, from, to, isFromExempt, isToExempt);\r\n    }\r\n    \r\n    function testDistributeTax(\r\n        address from,\r\n        uint256 taxAmount,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external returns (\r\n        uint256 feeAmount,\r\n        uint256 burnAmount,\r\n        uint256 donationAmount\r\n    ) {\r\n        return TaxManager.distributeTax(from, taxAmount, feeWallet, donationWallet);\r\n    }\r\n    \r\n    function testLogTransferAnalytics(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external {\r\n        TaxManager.logTransferAnalytics(taxData, from, to, amount);\r\n    }\r\n    \r\n    function testGetTaxInfo() external pure returns (uint256 buyTax, uint256 sellTax) {\r\n        return TaxManager.getTaxInfo();\r\n    }\r\n    \r\n    function testIsAMMPair(address pair) external view returns (bool) {\r\n        return TaxManager.isAMMPair(taxData, pair);\r\n    }\r\n    \r\n    function testIsTradingEnabled() external view returns (bool) {\r\n        return TaxManager.isTradingEnabled(taxData);\r\n    }\r\n    \r\n    function testCalculateTransferAmounts(uint256 amount, bool shouldTax) external pure returns (\r\n        uint256 transferAmount,\r\n        uint256 taxAmount\r\n    ) {\r\n        return TaxManager.calculateTransferAmounts(amount, shouldTax);\r\n    }\r\n    \r\n    function testValidateAMMPairSetting(\r\n        address pair,\r\n        address owner,\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external pure {\r\n        TaxManager.validateAMMPairSetting(pair, owner, feeWallet, donationWallet);\r\n    }\r\n    \r\n    function testGetTaxStatus(\r\n        address from,\r\n        address to,\r\n        bool isFromExempt,\r\n        bool isToExempt\r\n    ) external view returns (\r\n        bool willApplyTax,\r\n        bool isFromAMM,\r\n        bool isToAMM,\r\n        bool tradingActive\r\n    ) {\r\n        return TaxManager.getTaxStatus(taxData, from, to, isFromExempt, isToExempt);\r\n    }\r\n}"
    },
    "contracts/mocks/TestAMM.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract TestAMM {\r\n    // Simple contract to simulate AMM behavior for testing\r\n    \r\n    function getAddress() external view returns (address) {\r\n        return address(this);\r\n    }\r\n    \r\n    // Accept any token transfers\r\n    receive() external payable {}\r\n}"
    },
    "contracts/mocks/TestHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract TestHelpers {\r\n    // Event for testing event emission\r\n    event TestEvent(address indexed user, uint256 value, string message);\r\n    \r\n    // State variables for testing\r\n    uint256 public counter;\r\n    mapping(address => uint256) public userBalances;\r\n    address[] public users;\r\n    \r\n    // Modifier for testing access control\r\n    modifier onlyEvenCounter() {\r\n        require(counter % 2 == 0, \"Counter must be even\");\r\n        _;\r\n    }\r\n    \r\n    function incrementCounter() external {\r\n        counter++;\r\n        emit TestEvent(msg.sender, counter, \"Counter incremented\");\r\n    }\r\n    \r\n    function setUserBalance(address user, uint256 balance) external onlyEvenCounter {\r\n        if (userBalances[user] == 0 && balance > 0) {\r\n            users.push(user);\r\n        }\r\n        userBalances[user] = balance;\r\n        emit TestEvent(user, balance, \"Balance set\");\r\n    }\r\n    \r\n    function getUserCount() external view returns (uint256) {\r\n        return users.length;\r\n    }\r\n    \r\n    function getAllUsers() external view returns (address[] memory) {\r\n        return users;\r\n    }\r\n    \r\n    // Function to test gas consumption\r\n    function expensiveOperation(uint256 iterations) external {\r\n        for (uint256 i = 0; i < iterations; i++) {\r\n            counter += i;\r\n        }\r\n    }\r\n    \r\n    // Function to test revert conditions\r\n    function testRevert(bool shouldRevert, string memory message) external pure {\r\n        if (shouldRevert) {\r\n            revert(message);\r\n        }\r\n    }\r\n    \r\n    // Function to test different return types\r\n    function getMultipleValues() external view returns (\r\n        uint256 number,\r\n        string memory text,\r\n        bool flag,\r\n        address addr\r\n    ) {\r\n        return (counter, \"test\", counter > 0, address(this));\r\n    }\r\n    \r\n    // Function to test array operations\r\n    function processArray(uint256[] memory numbers) external pure returns (uint256 sum, uint256 max) {\r\n        sum = 0;\r\n        max = 0;\r\n        \r\n        for (uint256 i = 0; i < numbers.length; i++) {\r\n            sum += numbers[i];\r\n            if (numbers[i] > max) {\r\n                max = numbers[i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Function to test struct operations\r\n    struct TestStruct {\r\n        uint256 id;\r\n        string name;\r\n        bool active;\r\n    }\r\n    \r\n    mapping(uint256 => TestStruct) public testStructs;\r\n    uint256 public structCount;\r\n    \r\n    function createStruct(string memory name, bool active) external returns (uint256) {\r\n        uint256 id = structCount++;\r\n        testStructs[id] = TestStruct(id, name, active);\r\n        return id;\r\n    }\r\n    \r\n    function updateStruct(uint256 id, string memory name, bool active) external {\r\n        require(id < structCount, \"Invalid struct ID\");\r\n        testStructs[id].name = name;\r\n        testStructs[id].active = active;\r\n    }\r\n    \r\n    // Function to test token interactions\r\n    function transferTokens(address token, address to, uint256 amount) external {\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n    \r\n    function transferTokensFrom(address token, address from, address to, uint256 amount) external {\r\n        IERC20(token).transferFrom(from, to, amount);\r\n    }\r\n    \r\n    // Function to test time-based operations\r\n    uint256 public lastActionTime;\r\n    \r\n    function timeBasedAction() external {\r\n        require(block.timestamp > lastActionTime + 1 hours, \"Too soon\");\r\n        lastActionTime = block.timestamp;\r\n        counter++;\r\n    }\r\n    \r\n    // Function to test ETH handling\r\n    function depositETH() external payable {\r\n        userBalances[msg.sender] += msg.value;\r\n        emit TestEvent(msg.sender, msg.value, \"ETH deposited\");\r\n    }\r\n    \r\n    function withdrawETH(uint256 amount) external {\r\n        require(userBalances[msg.sender] >= amount, \"Insufficient balance\");\r\n        userBalances[msg.sender] -= amount;\r\n        payable(msg.sender).transfer(amount);\r\n        emit TestEvent(msg.sender, amount, \"ETH withdrawn\");\r\n    }\r\n    \r\n    // Function to test complex calculations\r\n    function complexCalculation(uint256 a, uint256 b, uint256 c) external pure returns (uint256) {\r\n        // Simulate complex mathematical operations\r\n        uint256 result = (a * b) / (c + 1);\r\n        result = (result ** 2) % 1000000;\r\n        return result;\r\n    }\r\n    \r\n    receive() external payable {\r\n        userBalances[msg.sender] += msg.value;\r\n        emit TestEvent(msg.sender, msg.value, \"ETH received\");\r\n    }\r\n}"
    },
    "contracts/mocks/WalletManagerTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"../libraries/WalletManager.sol\";\r\n\r\n/**\r\n * @title WalletManagerTestContract\r\n * @dev Test contract to expose WalletManager library functions for testing\r\n */\r\ncontract WalletManagerTestContract {\r\n    using WalletManager for WalletManager.WalletData;\r\n\r\n    WalletManager.WalletData private walletData;\r\n    address public owner;\r\n    address public contractAddress;\r\n\r\n    event TestEvent(string message);\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        contractAddress = address(this);\r\n    }\r\n\r\n    // Initialize wallets\r\n    function initializeWallets(\r\n        address _feeWallet,\r\n        address _donationWallet,\r\n        address[] memory _initialExemptAccounts\r\n    ) external {\r\n        walletData.initializeWallets(\r\n            _feeWallet,\r\n            _donationWallet,\r\n            owner,\r\n            contractAddress,\r\n            _initialExemptAccounts\r\n        );\r\n    }\r\n\r\n    // Update fee wallet\r\n    function updateFeeWallet(address newFeeWallet) external {\r\n        walletData.updateFeeWallet(newFeeWallet, owner, contractAddress);\r\n    }\r\n\r\n    // Update donation wallet\r\n    function updateDonationWallet(address newDonationWallet) external {\r\n        walletData.updateDonationWallet(newDonationWallet, owner, contractAddress);\r\n    }\r\n\r\n    // Update both wallets\r\n    function updateBothWallets(\r\n        address newFeeWallet,\r\n        address newDonationWallet\r\n    ) external {\r\n        walletData.updateBothWallets(\r\n            newFeeWallet,\r\n            newDonationWallet,\r\n            owner,\r\n            contractAddress\r\n        );\r\n    }\r\n\r\n    // Update tax exemption\r\n    function updateTaxExemption(\r\n        address account,\r\n        bool isExempt\r\n    ) external {\r\n        walletData.updateTaxExemption(account, isExempt, owner, contractAddress);\r\n    }\r\n\r\n    // Validate single wallet\r\n    function validateSingleWallet(address wallet) external view {\r\n        WalletManager.validateSingleWallet(wallet, contractAddress);\r\n    }\r\n\r\n    // Validate wallet pair\r\n    function validateWalletPair(\r\n        address feeWallet,\r\n        address donationWallet\r\n    ) external view {\r\n        WalletManager.validateWalletPair(feeWallet, donationWallet, contractAddress);\r\n    }\r\n\r\n    // Check if exempt from tax\r\n    function isExemptFromTax(address account) external view returns (bool) {\r\n        return WalletManager.isExemptFromTax(walletData, account);\r\n    }\r\n\r\n    // Get wallets\r\n    function getWallets() external view returns (address feeWallet, address donationWallet) {\r\n        return walletData.getWallets();\r\n    }\r\n\r\n    // Validate AMM pair wallet\r\n    function validateAMMPairWallet(address pair) external view {\r\n        walletData.validateAMMPairWallet(pair, owner);\r\n    }\r\n\r\n    // Get fee wallet\r\n    function getFeeWallet() external view returns (address) {\r\n        (address feeWallet, ) = walletData.getWallets();\r\n        return feeWallet;\r\n    }\r\n\r\n    // Get donation wallet\r\n    function getDonationWallet() external view returns (address) {\r\n        (, address donationWallet) = walletData.getWallets();\r\n        return donationWallet;\r\n    }\r\n\r\n    // Get burn wallet constant\r\n    function getBurnWallet() external pure returns (address) {\r\n        return WalletManager.BURN_WALLET;\r\n    }\r\n\r\n    // Helper to change owner for testing\r\n    function setOwner(address newOwner) external {\r\n        owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/SylvanToken.sol": {
      "content": "/**\r\n *                 \r\n *            \r\n *            \r\n *             \r\n *          \r\n *             \r\n * \r\n * SylvanToken - Advanced BEP-20 Token on Binance Smart Chain\r\n * Website: https://www.sylvantoken.org\r\n * Telegram: https://t.me/sylvantoken\r\n * Twitter: https://x.com/SylvanToken\r\n * \r\n * Features:\r\n * - 1% Transaction Tax (50% dev, 25% burn, 25% charity)\r\n * - Advanced Vesting System\r\n * - Secure & Gas Optimized\r\n * - Community Driven\r\n */\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n// Interface imports\r\nimport \"./interfaces/IEnhancedFeeManager.sol\";\r\nimport \"./interfaces/IVestingManager.sol\";\r\nimport \"./interfaces/IAdminWalletHandler.sol\";\r\n\r\n// Library imports for existing functionality\r\nimport \"./libraries/WalletManager.sol\";\r\nimport \"./libraries/TaxManager.sol\";\r\nimport \"./libraries/InputValidator.sol\";\r\n\r\n/**\r\n * @title SylvanToken\r\n * @author Sylvan Team\r\n * @notice BEP-20 token with advanced vesting, fee distribution, and lock mechanisms\r\n * @dev Implements ERC20 standard with additional features:\r\n *      - Universal 1% transaction fee (50% operations, 25% donations, 25% burn)\r\n *      - Advanced vesting system with cliff periods and proportional burning\r\n *      - Dynamic fee exemption management\r\n *      - Reentrancy protection on all state-changing functions\r\n *      - Gas-optimized storage access patterns\r\n * @custom:security-contact security@sylvantoken.org\r\n */\r\ncontract SylvanToken is ERC20, Ownable, ReentrancyGuard, IEnhancedFeeManager, IVestingManager, IAdminWalletHandler {\r\n    using Address for address;\r\n    \r\n    // Library using statements\r\n    using TaxManager for TaxManager.TaxData;\r\n    \r\n    //  Token Constants\r\n    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 * 10**18;\r\n    \r\n    // Enhanced Fee System Constants\r\n    uint256 public constant UNIVERSAL_FEE_RATE = 100; // 1% in basis points\r\n    uint256 public constant FEE_DENOMINATOR = 10000;\r\n    uint256 public constant FEE_DISTRIBUTION_FEE = 5000; // 50%\r\n    uint256 public constant FEE_DISTRIBUTION_DONATION = 2500; // 25%\r\n    uint256 public constant FEE_DISTRIBUTION_BURN = 2500; // 25%\r\n    \r\n    // Vesting Constants\r\n    uint256 public constant ADMIN_IMMEDIATE_RELEASE = 1000; // 10%\r\n    uint256 public constant ADMIN_LOCK_PERCENTAGE = 9000; // 90%\r\n    uint256 public constant ADMIN_MONTHLY_RELEASE = 500; // 5%\r\n    uint256 public constant LOCKED_MONTHLY_RELEASE = 300; // 3%\r\n    uint256 public constant PROPORTIONAL_BURN = 1000; // 10%\r\n    uint256 public constant BASIS_POINTS = 10000;\r\n    \r\n    // Time Constants\r\n    uint256 public constant SECONDS_PER_DAY = 86400;\r\n    uint256 public constant SECONDS_PER_MONTH = 2629746; // Average month in seconds\r\n    \r\n    // Dead wallet for burning\r\n    address public constant DEAD_WALLET = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    //  Library Data Structures\r\n    TaxManager.TaxData private taxData;\r\n    \r\n    //  Enhanced Fee Exemption Data Structures\r\n    struct FeeExemptionData {\r\n        mapping(address => bool) exemptWallets;\r\n        address[] exemptList;\r\n        uint256 exemptCount;\r\n    }\r\n    \r\n    FeeExemptionData private feeExemptionData;\r\n    \r\n    //  Vesting Data Structures\r\n    mapping(address => VestingSchedule) private vestingSchedules;\r\n    mapping(address => AdminWalletConfig) private adminConfigs;\r\n    address[] private configuredAdmins;\r\n    \r\n    // Global vesting tracking\r\n    uint256 private totalVestedAmount;\r\n    uint256 private totalReleasedAmount;\r\n    uint256 private totalBurnedAmount;\r\n    \r\n    //  Enhanced tracking\r\n    uint256 public totalFeesCollected;\r\n    uint256 public totalTokensBurned;\r\n    \r\n    //  Wallet addresses\r\n    address public feeWallet;\r\n    address public donationWallet;\r\n    \r\n    //  AMM and Emergency Controls\r\n    mapping(address => bool) private ammPairs;\r\n    \r\n    //  Enhanced Events\r\n    event UniversalFeeApplied(address indexed from, address indexed to, uint256 amount, uint256 feeAmount);\r\n    event FeeDistributed(uint256 feeAmount, uint256 donationAmount, uint256 burnAmount);\r\n    event ProportionalBurn(address indexed beneficiary, uint256 burnAmount, uint256 totalBurned);\r\n    \r\n    // Custom errors for enhanced functionality\r\n    error UnauthorizedExemptionChange();\r\n    error WalletAlreadyExempt(address wallet);\r\n    error WalletNotExempt(address wallet);\r\n    error InvalidExemptionConfiguration();\r\n    error VestingAlreadyExists(address beneficiary);\r\n    error NoVestingSchedule(address beneficiary);\r\n    error VestingNotStarted(address beneficiary);\r\n    error CliffPeriodActive(address beneficiary);\r\n    error NoTokensToRelease(address beneficiary);\r\n    error InvalidVestingParameters();\r\n    error InsufficientUnlockedBalance(address account, uint256 requested, uint256 available);\r\n    error AdminWalletAlreadyConfigured(address admin);\r\n    error AdminWalletNotConfigured(address admin);\r\n    error InvalidAdminAllocation(uint256 amount);\r\n    error ImmediateReleaseAlreadyProcessed(address admin);\r\n    error ZeroAddress();\r\n    error InvalidAmount();\r\n    \r\n    constructor(\r\n        address _feeWallet,\r\n        address _donationWallet,\r\n        address[] memory _initialExemptAccounts\r\n    ) ERC20(\"Sylvan Token\", \"SYL\") {\r\n        // Validate constructor parameters\r\n        if (_feeWallet == address(0) || _donationWallet == address(0)) {\r\n            revert ZeroAddress();\r\n        }\r\n        \r\n        // Set wallet addresses\r\n        feeWallet = _feeWallet;\r\n        donationWallet = _donationWallet;\r\n        \r\n        // Initialize fee exemptions with initial accounts\r\n        _initializeFeeExemptions(_initialExemptAccounts);\r\n        \r\n        // Mint total supply to owner\r\n        _mint(owner(), TOTAL_SUPPLY);\r\n    }\r\n    \r\n    /**\r\n     * @dev Initialize fee exemptions with initial accounts\r\n     * @param _initialExemptAccounts Array of initially exempt accounts\r\n     */\r\n    function _initializeFeeExemptions(address[] memory _initialExemptAccounts) private {\r\n        // Always exempt contract itself, owner, fee wallet, and donation wallet\r\n        feeExemptionData.exemptWallets[address(this)] = true;\r\n        feeExemptionData.exemptWallets[owner()] = true;\r\n        feeExemptionData.exemptWallets[feeWallet] = true;\r\n        feeExemptionData.exemptWallets[donationWallet] = true;\r\n        feeExemptionData.exemptWallets[DEAD_WALLET] = true;\r\n        \r\n        feeExemptionData.exemptList.push(address(this));\r\n        feeExemptionData.exemptList.push(owner());\r\n        feeExemptionData.exemptList.push(feeWallet);\r\n        feeExemptionData.exemptList.push(donationWallet);\r\n        feeExemptionData.exemptList.push(DEAD_WALLET);\r\n        feeExemptionData.exemptCount = 5;\r\n        \r\n        // Add initial exempt accounts\r\n        for (uint256 i = 0; i < _initialExemptAccounts.length; i++) {\r\n            address account = _initialExemptAccounts[i];\r\n            if (account != address(0) && !feeExemptionData.exemptWallets[account]) {\r\n                feeExemptionData.exemptWallets[account] = true;\r\n                feeExemptionData.exemptList.push(account);\r\n                feeExemptionData.exemptCount++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // ============================================================================\r\n    // ENHANCED FEE MANAGER IMPLEMENTATION\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @dev Check if a wallet is exempt from fees\r\n     */\r\n    function isExempt(address wallet) public view override returns (bool) {\r\n        return feeExemptionData.exemptWallets[wallet];\r\n    }\r\n    \r\n    /**\r\n     * @dev Add a wallet to the fee exemption list\r\n     */\r\n    function addExemptWallet(address wallet) external override onlyOwner {\r\n        if (wallet == address(0)) revert ZeroAddress();\r\n        if (feeExemptionData.exemptWallets[wallet]) revert WalletAlreadyExempt(wallet);\r\n        \r\n        feeExemptionData.exemptWallets[wallet] = true;\r\n        feeExemptionData.exemptList.push(wallet);\r\n        feeExemptionData.exemptCount++;\r\n        \r\n        emit FeeExemptionChanged(wallet, true);\r\n    }\r\n    \r\n    /**\r\n     * @dev Remove a wallet from the fee exemption list\r\n     */\r\n    function removeExemptWallet(address wallet) external override onlyOwner {\r\n        if (!feeExemptionData.exemptWallets[wallet]) revert WalletNotExempt(wallet);\r\n        \r\n        feeExemptionData.exemptWallets[wallet] = false;\r\n        \r\n        // Remove from exemptList array\r\n        for (uint256 i = 0; i < feeExemptionData.exemptList.length; i++) {\r\n            if (feeExemptionData.exemptList[i] == wallet) {\r\n                feeExemptionData.exemptList[i] = feeExemptionData.exemptList[feeExemptionData.exemptList.length - 1];\r\n                feeExemptionData.exemptList.pop();\r\n                break;\r\n            }\r\n        }\r\n        \r\n        feeExemptionData.exemptCount--;\r\n        emit FeeExemptionChanged(wallet, false);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get all exempt wallets\r\n     */\r\n    function getExemptWallets() external view override returns (address[] memory) {\r\n        address[] memory activeExempt = new address[](feeExemptionData.exemptCount);\r\n        uint256 activeIndex = 0;\r\n        \r\n        for (uint256 i = 0; i < feeExemptionData.exemptList.length; i++) {\r\n            if (feeExemptionData.exemptWallets[feeExemptionData.exemptList[i]]) {\r\n                activeExempt[activeIndex] = feeExemptionData.exemptList[i];\r\n                activeIndex++;\r\n            }\r\n        }\r\n        \r\n        return activeExempt;\r\n    }\r\n    \r\n    /**\r\n     * @dev Load exemptions from configuration data\r\n     * @param configWallets Array of wallet addresses to configure\r\n     * @param exemptStatuses Array of exemption statuses (true = exempt, false = not exempt)\r\n     */\r\n    function loadExemptionsFromConfig(\r\n        address[] calldata configWallets,\r\n        bool[] calldata exemptStatuses\r\n    ) external onlyOwner {\r\n        if (configWallets.length != exemptStatuses.length) {\r\n            revert InvalidExemptionConfiguration();\r\n        }\r\n        \r\n        for (uint256 i = 0; i < configWallets.length; i++) {\r\n            address wallet = configWallets[i];\r\n            bool shouldExempt = exemptStatuses[i];\r\n            \r\n            if (wallet == address(0)) continue;\r\n            \r\n            // Current exemption status\r\n            bool currentlyExempt = feeExemptionData.exemptWallets[wallet];\r\n            \r\n            if (shouldExempt && !currentlyExempt) {\r\n                // Add to exemption\r\n                feeExemptionData.exemptWallets[wallet] = true;\r\n                feeExemptionData.exemptList.push(wallet);\r\n                feeExemptionData.exemptCount++;\r\n                emit FeeExemptionChanged(wallet, true);\r\n            } else if (!shouldExempt && currentlyExempt) {\r\n                // Remove from exemption\r\n                feeExemptionData.exemptWallets[wallet] = false;\r\n                \r\n                // Remove from exemptList array\r\n                for (uint256 j = 0; j < feeExemptionData.exemptList.length; j++) {\r\n                    if (feeExemptionData.exemptList[j] == wallet) {\r\n                        feeExemptionData.exemptList[j] = feeExemptionData.exemptList[feeExemptionData.exemptList.length - 1];\r\n                        feeExemptionData.exemptList.pop();\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                feeExemptionData.exemptCount--;\r\n                emit FeeExemptionChanged(wallet, false);\r\n            }\r\n        }\r\n        \r\n        emit ExemptionConfigLoaded(feeExemptionData.exemptCount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Load exemptions from configuration (overloaded for backward compatibility)\r\n     */\r\n    function loadExemptionsFromConfig() external override onlyOwner {\r\n        // Emit event to indicate config loading was called\r\n        emit ExemptionConfigLoaded(feeExemptionData.exemptCount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Add multiple wallets to exemption list in batch\r\n     */\r\n    function addExemptWalletsBatch(address[] calldata wallets) external override onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            address wallet = wallets[i];\r\n            if (wallet != address(0) && !feeExemptionData.exemptWallets[wallet]) {\r\n                feeExemptionData.exemptWallets[wallet] = true;\r\n                feeExemptionData.exemptList.push(wallet);\r\n                feeExemptionData.exemptCount++;\r\n            }\r\n        }\r\n        \r\n        emit BatchExemptionUpdate(wallets, true);\r\n    }\r\n    \r\n    /**\r\n     * @dev Remove multiple wallets from exemption list in batch\r\n     */\r\n    function removeExemptWalletsBatch(address[] calldata wallets) external override onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            address wallet = wallets[i];\r\n            if (feeExemptionData.exemptWallets[wallet]) {\r\n                feeExemptionData.exemptWallets[wallet] = false;\r\n                \r\n                // Remove from exemptList array\r\n                for (uint256 j = 0; j < feeExemptionData.exemptList.length; j++) {\r\n                    if (feeExemptionData.exemptList[j] == wallet) {\r\n                        feeExemptionData.exemptList[j] = feeExemptionData.exemptList[feeExemptionData.exemptList.length - 1];\r\n                        feeExemptionData.exemptList.pop();\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                feeExemptionData.exemptCount--;\r\n            }\r\n        }\r\n        \r\n        emit BatchExemptionUpdate(wallets, false);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get the count of exempt wallets\r\n     */\r\n    function getExemptWalletCount() external view override returns (uint256) {\r\n        return feeExemptionData.exemptCount;\r\n    }\r\n    \r\n    // ============================================================================\r\n    // VESTING MANAGER IMPLEMENTATION (Basic Structure)\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @dev Create a new vesting schedule\r\n     */\r\n    function createVestingSchedule(\r\n        address beneficiary,\r\n        uint256 amount,\r\n        uint256 cliffDays,\r\n        uint256 vestingMonths,\r\n        uint256 releasePercentage,\r\n        uint256 burnPercentage,\r\n        bool isAdmin\r\n    ) external override onlyOwner {\r\n        if (beneficiary == address(0)) revert ZeroAddress();\r\n        if (amount == 0) revert InvalidAmount();\r\n        if (vestingSchedules[beneficiary].isActive) revert VestingAlreadyExists(beneficiary);\r\n        \r\n        vestingSchedules[beneficiary] = VestingSchedule({\r\n            totalAmount: amount,\r\n            releasedAmount: 0,\r\n            burnedAmount: 0,\r\n            startTime: block.timestamp,\r\n            cliffDuration: cliffDays * SECONDS_PER_DAY,\r\n            vestingDuration: vestingMonths * SECONDS_PER_MONTH,\r\n            releasePercentage: releasePercentage,\r\n            burnPercentage: burnPercentage,\r\n            isAdmin: isAdmin,\r\n            isActive: true\r\n        });\r\n        \r\n        totalVestedAmount += amount;\r\n        \r\n        emit VestingScheduleCreated(\r\n            beneficiary,\r\n            amount,\r\n            cliffDays * SECONDS_PER_DAY,\r\n            vestingMonths * SECONDS_PER_MONTH,\r\n            isAdmin\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Release vested tokens for a beneficiary (admin or locked wallet)\r\n     * @notice Routes to correct calculation based on beneficiary type\r\n     * @param beneficiary The address to release tokens for\r\n     * @return releasedAmount Amount of tokens released to beneficiary (after 10% burn)\r\n     * @return burnedAmount Amount of tokens burned (10% of total release)\r\n     * \r\n     * @custom:calculation-admin For admin wallets: 5% of total allocation monthly over 18 months\r\n     * @custom:calculation-locked For locked wallets: 3% of locked amount monthly over 34 months\r\n     * @custom:security Uses schedule.isAdmin flag to route to correct helper function\r\n     * \r\n     * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\r\n     */\r\n    function releaseVestedTokens(address beneficiary) external override returns (uint256 releasedAmount, uint256 burnedAmount) {\r\n        VestingSchedule storage schedule = vestingSchedules[beneficiary];\r\n        \r\n        if (!schedule.isActive) revert NoVestingSchedule(beneficiary);\r\n        \r\n        // Check if vesting has started\r\n        if (block.timestamp < schedule.startTime) revert VestingNotStarted(beneficiary);\r\n        \r\n        // Check if cliff period has passed\r\n        if (block.timestamp < schedule.startTime + schedule.cliffDuration) revert CliffPeriodActive(beneficiary);\r\n        \r\n        // SECURITY FIX: Route to correct calculation based on beneficiary type\r\n        // Admin wallets: Calculate based on total allocation (5% monthly)\r\n        // Locked wallets: Calculate based on locked amount (3% monthly)\r\n        (uint256 availableAmount, uint256 burnAmount) = schedule.isAdmin \r\n            ? _calculateAvailableRelease(beneficiary)\r\n            : _calculateLockedWalletRelease(beneficiary);\r\n        \r\n        if (availableAmount == 0) revert NoTokensToRelease(beneficiary);\r\n        \r\n        // Update schedule tracking\r\n        schedule.releasedAmount += availableAmount;\r\n        schedule.burnedAmount += burnAmount;\r\n        \r\n        // Calculate actual amounts: 10% burn, 90% to beneficiary\r\n        burnedAmount = burnAmount;\r\n        releasedAmount = availableAmount - burnedAmount;\r\n        \r\n        // Transfer burn amount to dead wallet (Requirement 5.2)\r\n        _transfer(owner(), DEAD_WALLET, burnedAmount);\r\n        \r\n        // Transfer remaining 90% to beneficiary (Requirement 5.3)\r\n        _transfer(owner(), beneficiary, releasedAmount);\r\n        \r\n        // Update global tracking\r\n        totalReleasedAmount += availableAmount;\r\n        totalBurnedAmount += burnedAmount;\r\n        totalTokensBurned += burnedAmount;\r\n        \r\n        emit TokensReleased(beneficiary, releasedAmount, burnedAmount, schedule.releasedAmount);\r\n        emit ProportionalBurn(beneficiary, burnedAmount, totalBurnedAmount);\r\n        \r\n        return (releasedAmount, burnedAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get vesting information for a beneficiary\r\n     */\r\n    function getVestingInfo(address beneficiary) external view override returns (VestingSchedule memory) {\r\n        return vestingSchedules[beneficiary];\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate releasable amount for locked wallet with 3% monthly releases\r\n     * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\r\n     */\r\n    function calculateReleasableAmount(address beneficiary) external view override returns (uint256 releasableAmount, uint256 burnAmount) {\r\n        return _calculateLockedWalletRelease(beneficiary);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if vesting schedule exists\r\n     */\r\n    function hasVestingSchedule(address beneficiary) external view override returns (bool) {\r\n        return vestingSchedules[beneficiary].isActive;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total vested amount\r\n     */\r\n    function getTotalVestedAmount() external view override returns (uint256) {\r\n        return totalVestedAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total released amount\r\n     */\r\n    function getTotalReleasedAmount() external view override returns (uint256) {\r\n        return totalReleasedAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total burned amount\r\n     */\r\n    function getTotalBurnedAmount() external view override returns (uint256) {\r\n        return totalBurnedAmount;\r\n    }\r\n    \r\n    // ============================================================================\r\n    // ADMIN WALLET HANDLER IMPLEMENTATION\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @dev Configure an admin wallet with 10% immediate access and 90% vested over 18 months\r\n     * @notice Stores TOTAL allocation in VestingSchedule.totalAmount for correct calculations\r\n     * @param admin The admin wallet address\r\n     * @param allocation The total token allocation (100%)\r\n     * \r\n     * @custom:distribution 10% immediate release, 90% vested over 18 months\r\n     * @custom:monthly-release 5% of total allocation per month (not 5% of locked amount)\r\n     * @custom:vesting-math 18 months  5% = 90% of total allocation\r\n     * \r\n     * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5\r\n     */\r\n    function configureAdminWallet(address admin, uint256 allocation) external override onlyOwner {\r\n        if (admin == address(0)) revert ZeroAddress();\r\n        if (allocation == 0) revert InvalidAmount();\r\n        if (adminConfigs[admin].isConfigured) revert AdminWalletAlreadyConfigured(admin);\r\n        \r\n        // Calculate 10% immediate release and 90% locked amount (Requirements 2.1, 2.2)\r\n        uint256 immediateRelease = (allocation * ADMIN_IMMEDIATE_RELEASE) / BASIS_POINTS; // 10%\r\n        uint256 lockedAmount = allocation - immediateRelease; // 90%\r\n        \r\n        adminConfigs[admin] = AdminWalletConfig({\r\n            totalAllocation: allocation,\r\n            immediateRelease: immediateRelease,\r\n            lockedAmount: lockedAmount,\r\n            releasedAmount: 0,\r\n            burnedAmount: 0,\r\n            isConfigured: true,\r\n            immediateReleased: false\r\n        });\r\n        \r\n        configuredAdmins.push(admin);\r\n        \r\n        // SECURITY FIX: Store total allocation (not locked amount) for admin wallets\r\n        // This ensures _calculateAvailableRelease() calculates 5% of total allocation monthly\r\n        // Vesting schedule configuration:\r\n        // - Total amount: FULL allocation (100%) - used for monthly 5% calculation\r\n        // - Cliff period: 0 days (immediate start after initial release)\r\n        // - Vesting duration: 18 months\r\n        // - Release percentage: 500 basis points (5% of total allocation monthly)\r\n        // - Burn percentage: 1000 basis points (10% of each release)\r\n        // Mathematical verification: 18 months  5% = 90% of total allocation \r\n        vestingSchedules[admin] = VestingSchedule({\r\n            totalAmount: allocation, // FIXED: Store full allocation, not locked amount\r\n            releasedAmount: 0,\r\n            burnedAmount: 0,\r\n            startTime: block.timestamp,\r\n            cliffDuration: 0, // No cliff for admin wallets after initial release\r\n            vestingDuration: 18 * SECONDS_PER_MONTH, // 18 months total vesting\r\n            releasePercentage: ADMIN_MONTHLY_RELEASE, // 5% monthly of total allocation\r\n            burnPercentage: PROPORTIONAL_BURN, // 10% burn\r\n            isAdmin: true,\r\n            isActive: true\r\n        });\r\n        \r\n        totalVestedAmount += allocation; // Track full allocation in global vesting\r\n        \r\n        emit AdminWalletConfigured(admin, allocation, immediateRelease, lockedAmount);\r\n        emit VestingScheduleCreated(admin, lockedAmount, 0, 18 * SECONDS_PER_MONTH, true);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get admin configuration\r\n     */\r\n    function getAdminConfig(address admin) external view override returns (AdminWalletConfig memory) {\r\n        return adminConfigs[admin];\r\n    }\r\n    \r\n    /**\r\n     * @dev Process initial 10% release for admin wallet\r\n     * Requirements: 2.1 - 10% immediate access\r\n     */\r\n    function processInitialRelease(address admin) external override onlyOwner returns (uint256 releasedAmount) {\r\n        AdminWalletConfig storage config = adminConfigs[admin];\r\n        \r\n        if (!config.isConfigured) revert AdminWalletNotConfigured(admin);\r\n        if (config.immediateReleased) revert ImmediateReleaseAlreadyProcessed(admin);\r\n        \r\n        releasedAmount = config.immediateRelease;\r\n        \r\n        // Mark immediate release as processed\r\n        config.immediateReleased = true;\r\n        config.releasedAmount += releasedAmount;\r\n        \r\n        // Transfer 10% immediately to admin wallet\r\n        _transfer(owner(), admin, releasedAmount);\r\n        \r\n        totalReleasedAmount += releasedAmount;\r\n        \r\n        emit InitialReleaseProcessed(admin, releasedAmount);\r\n        \r\n        return releasedAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Process monthly release for admin wallet with proportional burning\r\n     * Requirements: 2.4, 2.5, 3.1, 3.2, 3.3, 3.4, 3.5\r\n     */\r\n    function processMonthlyRelease(address admin) external override onlyOwner returns (uint256 releasedAmount, uint256 burnedAmount) {\r\n        AdminWalletConfig storage config = adminConfigs[admin];\r\n        VestingSchedule storage schedule = vestingSchedules[admin];\r\n        \r\n        if (!config.isConfigured) revert AdminWalletNotConfigured(admin);\r\n        if (!schedule.isActive) revert NoVestingSchedule(admin);\r\n        \r\n        // Calculate available release amount using internal function\r\n        (uint256 availableAmount, uint256 burnAmount) = _calculateAvailableRelease(admin);\r\n        \r\n        if (availableAmount == 0) revert NoTokensToRelease(admin);\r\n        \r\n        // Update tracking\r\n        schedule.releasedAmount += availableAmount;\r\n        schedule.burnedAmount += burnAmount;\r\n        config.releasedAmount += availableAmount;\r\n        config.burnedAmount += burnAmount;\r\n        \r\n        // Calculate actual amounts: 10% burn, 90% to admin (Requirements 3.1, 3.2, 3.3)\r\n        burnedAmount = burnAmount;\r\n        releasedAmount = availableAmount - burnedAmount;\r\n        \r\n        // Transfer burn amount to dead wallet (Requirement 3.2)\r\n        _transfer(owner(), DEAD_WALLET, burnedAmount);\r\n        \r\n        // Transfer remaining 90% to admin wallet (Requirement 3.3)\r\n        _transfer(owner(), admin, releasedAmount);\r\n        \r\n        // Update global tracking\r\n        totalReleasedAmount += availableAmount;\r\n        totalBurnedAmount += burnedAmount;\r\n        totalTokensBurned += burnedAmount;\r\n        \r\n        emit MonthlyReleaseProcessed(admin, releasedAmount, burnedAmount, config.releasedAmount);\r\n        emit ProportionalBurn(admin, burnedAmount, totalBurnedAmount);\r\n        \r\n        return (releasedAmount, burnedAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if admin is configured\r\n     */\r\n    function isAdminConfigured(address admin) external view override returns (bool) {\r\n        return adminConfigs[admin].isConfigured;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to calculate available release amount for admin wallet\r\n     * Requirements: 2.4, 2.5 - Monthly 5% release calculation\r\n     */\r\n    function _calculateAvailableRelease(address admin) internal view returns (uint256 availableAmount, uint256 burnAmount) {\r\n        AdminWalletConfig storage config = adminConfigs[admin];\r\n        VestingSchedule storage schedule = vestingSchedules[admin];\r\n        \r\n        if (!config.isConfigured || !schedule.isActive) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        // Check if cliff period has passed (should be 0 for admin wallets)\r\n        if (block.timestamp < schedule.startTime + schedule.cliffDuration) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        // Calculate months elapsed since start\r\n        uint256 timeElapsed = block.timestamp - schedule.startTime;\r\n        uint256 monthsElapsed = timeElapsed / SECONDS_PER_MONTH;\r\n        \r\n        // Cap at maximum vesting duration\r\n        if (timeElapsed >= schedule.vestingDuration) {\r\n            monthsElapsed = schedule.vestingDuration / SECONDS_PER_MONTH;\r\n        }\r\n        \r\n        // Calculate total amount that should be released by now\r\n        // Monthly release is 5% of original allocation (Requirements 2.4, 2.5)\r\n        // Calculate based on the locked amount (schedule.totalAmount) since that's what's being vested\r\n        uint256 totalReleasableAmount = (schedule.totalAmount * schedule.releasePercentage * monthsElapsed) / BASIS_POINTS;\r\n        \r\n        // Subtract what has already been released\r\n        if (totalReleasableAmount <= schedule.releasedAmount) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        availableAmount = totalReleasableAmount - schedule.releasedAmount;\r\n        \r\n        // Calculate burn amount (10% of available amount) (Requirements 3.1, 3.4, 3.5)\r\n        burnAmount = (availableAmount * schedule.burnPercentage) / BASIS_POINTS;\r\n        \r\n        return (availableAmount, burnAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate available release amount for admin wallet\r\n     * Requirements: 2.4, 2.5 - Monthly 5% release calculation\r\n     */\r\n    function calculateAvailableRelease(address admin) external view override returns (uint256 availableAmount, uint256 burnAmount) {\r\n        return _calculateAvailableRelease(admin);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get configured admins\r\n     */\r\n    function getConfiguredAdmins() external view override returns (address[] memory) {\r\n        return configuredAdmins;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total admin allocations\r\n     */\r\n    function getTotalAdminAllocations() external view override returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < configuredAdmins.length; i++) {\r\n            total += adminConfigs[configuredAdmins[i]].totalAllocation;\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get admin wallet release status\r\n     */\r\n    function getAdminReleaseStatus(address admin) external view returns (\r\n        uint256 totalAllocation,\r\n        uint256 immediateReleased,\r\n        uint256 monthlyReleased,\r\n        uint256 totalBurned,\r\n        uint256 remainingLocked,\r\n        bool immediateProcessed\r\n    ) {\r\n        AdminWalletConfig storage config = adminConfigs[admin];\r\n        \r\n        if (!config.isConfigured) {\r\n            return (0, 0, 0, 0, 0, false);\r\n        }\r\n        \r\n        totalAllocation = config.totalAllocation;\r\n        immediateReleased = config.immediateReleased ? config.immediateRelease : 0;\r\n        monthlyReleased = config.releasedAmount - immediateReleased;\r\n        totalBurned = config.burnedAmount;\r\n        remainingLocked = config.lockedAmount - monthlyReleased - totalBurned;\r\n        immediateProcessed = config.immediateReleased;\r\n        \r\n        return (totalAllocation, immediateReleased, monthlyReleased, totalBurned, remainingLocked, immediateProcessed);\r\n    }\r\n    \r\n    // ============================================================================\r\n    // ENHANCED TRANSFER LOGIC\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @dev Enhanced transfer function with universal 1% fee\r\n     */\r\n    function _transfer(address from, address to, uint256 amount) internal override nonReentrant {\r\n        if (from == address(0) || to == address(0)) revert ZeroAddress();\r\n        if (amount == 0) revert InvalidAmount();\r\n        \r\n        // Check vesting lock - prevent transfer of locked tokens\r\n        // Gas optimization: Cache storage reads\r\n        VestingSchedule storage schedule = vestingSchedules[from];\r\n        if (schedule.isActive) {\r\n            uint256 currentBalance = balanceOf(from);\r\n            \r\n            // Gas optimization: Use unchecked for safe math operations\r\n            uint256 lockedAmount;\r\n            unchecked {\r\n                lockedAmount = schedule.totalAmount - schedule.releasedAmount;\r\n            }\r\n            \r\n            // Calculate available balance with 1 wei tolerance for rounding\r\n            uint256 availableBalance = currentBalance > lockedAmount ? currentBalance - lockedAmount : 0;\r\n            \r\n            // Wei tolerance: Allow 1 wei difference for rounding errors\r\n            if (amount > availableBalance + 1) {\r\n                revert InsufficientUnlockedBalance(from, amount, availableBalance);\r\n            }\r\n        }\r\n        \r\n        // Check if either sender OR receiver is exempt (Requirements 6.2, 6.3)\r\n        bool isFromExempt = isExempt(from);\r\n        bool isToExempt = isExempt(to);\r\n        bool shouldApplyFee = !isFromExempt && !isToExempt;\r\n        \r\n        if (shouldApplyFee && amount > 0) {\r\n            // Calculate 1% universal fee (Requirement 6.1)\r\n            uint256 feeAmount = (amount * UNIVERSAL_FEE_RATE) / FEE_DENOMINATOR;\r\n            uint256 transferAmount = amount - feeAmount;\r\n            \r\n            if (feeAmount > 0) {\r\n                // Distribute fee: 50% fee wallet, 25% donation, 25% burn (Requirement 6.4)\r\n                _distributeFee(from, feeAmount);\r\n                emit UniversalFeeApplied(from, to, amount, feeAmount);\r\n            }\r\n            \r\n            super._transfer(from, to, transferAmount);\r\n        } else {\r\n            super._transfer(from, to, amount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Distribute collected fees according to requirements\r\n     */\r\n    function _distributeFee(address from, uint256 feeAmount) private {\r\n        uint256 feeWalletAmount = (feeAmount * FEE_DISTRIBUTION_FEE) / BASIS_POINTS;\r\n        uint256 donationAmount = (feeAmount * FEE_DISTRIBUTION_DONATION) / BASIS_POINTS;\r\n        uint256 burnAmount = feeAmount - feeWalletAmount - donationAmount; // Remaining amount to handle rounding\r\n        \r\n        // Transfer to fee wallet (50%)\r\n        super._transfer(from, feeWallet, feeWalletAmount);\r\n        \r\n        // Transfer to donation wallet (25%)\r\n        super._transfer(from, donationWallet, donationAmount);\r\n        \r\n        // Transfer to dead wallet for burning (25%)\r\n        super._transfer(from, DEAD_WALLET, burnAmount);\r\n        \r\n        // Update tracking\r\n        totalFeesCollected += feeWalletAmount;\r\n        totalTokensBurned += burnAmount;\r\n        \r\n        emit FeeDistributed(feeWalletAmount, donationAmount, burnAmount);\r\n    }\r\n    \r\n    // ============================================================================\r\n    // VIEW FUNCTIONS\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @dev Get fee system statistics\r\n     */\r\n    function getFeeStats() external view returns (\r\n        uint256 _totalFeesCollected,\r\n        uint256 _totalTokensBurned,\r\n        uint256 _totalDonations\r\n    ) {\r\n        return (\r\n            totalFeesCollected,\r\n            totalTokensBurned,\r\n            balanceOf(donationWallet)\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Get vesting system statistics\r\n     */\r\n    function getVestingStats() external view returns (\r\n        uint256 _totalVested,\r\n        uint256 _totalReleased,\r\n        uint256 _totalBurned,\r\n        uint256 _activeSchedules\r\n    ) {\r\n        return (\r\n            totalVestedAmount,\r\n            totalReleasedAmount,\r\n            totalBurnedAmount,\r\n            configuredAdmins.length\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to calculate available release amount for locked wallet\r\n     * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5 - 3% monthly release with 34-month vesting\r\n     */\r\n    function _calculateLockedWalletRelease(address beneficiary) internal view returns (uint256 availableAmount, uint256 burnAmount) {\r\n        VestingSchedule storage schedule = vestingSchedules[beneficiary];\r\n        \r\n        if (!schedule.isActive) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        // Check if vesting has started\r\n        if (block.timestamp < schedule.startTime) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        // Check if cliff period has passed\r\n        if (block.timestamp < schedule.startTime + schedule.cliffDuration) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        // Calculate months elapsed since cliff period ended\r\n        uint256 timeElapsed = block.timestamp - (schedule.startTime + schedule.cliffDuration);\r\n        uint256 monthsElapsed = timeElapsed / SECONDS_PER_MONTH;\r\n        \r\n        // For locked wallets: 34-month vesting schedule (Requirement 5.5)\r\n        // Cap at maximum vesting duration\r\n        uint256 maxMonths = schedule.vestingDuration / SECONDS_PER_MONTH;\r\n        if (monthsElapsed > maxMonths) {\r\n            monthsElapsed = maxMonths;\r\n        }\r\n        \r\n        // Calculate total amount that should be released by now\r\n        // For locked wallets: 3% monthly release (Requirement 5.1)\r\n        uint256 totalReleasableAmount;\r\n        \r\n        if (schedule.isAdmin) {\r\n            // Admin wallets: 5% of original allocation monthly\r\n            totalReleasableAmount = (schedule.totalAmount * schedule.releasePercentage * monthsElapsed) / BASIS_POINTS;\r\n        } else {\r\n            // Locked wallets: 3% of original allocation monthly (Requirement 5.1)\r\n            totalReleasableAmount = (schedule.totalAmount * LOCKED_MONTHLY_RELEASE * monthsElapsed) / BASIS_POINTS;\r\n        }\r\n        \r\n        // Ensure we don't exceed total amount\r\n        if (totalReleasableAmount > schedule.totalAmount) {\r\n            totalReleasableAmount = schedule.totalAmount;\r\n        }\r\n        \r\n        // Subtract what has already been released\r\n        if (totalReleasableAmount <= schedule.releasedAmount) {\r\n            return (0, 0);\r\n        }\r\n        \r\n        availableAmount = totalReleasableAmount - schedule.releasedAmount;\r\n        \r\n        // Calculate burn amount (10% of available amount) (Requirements 5.2, 5.3, 5.4)\r\n        burnAmount = (availableAmount * PROPORTIONAL_BURN) / BASIS_POINTS;\r\n        \r\n        return (availableAmount, burnAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Create locked wallet vesting schedule with 34-month duration\r\n     * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\r\n     */\r\n    function createLockedWalletVesting(\r\n        address lockedWallet,\r\n        uint256 amount,\r\n        uint256 cliffDays\r\n    ) external onlyOwner {\r\n        if (lockedWallet == address(0)) revert ZeroAddress();\r\n        if (amount == 0) revert InvalidAmount();\r\n        if (vestingSchedules[lockedWallet].isActive) revert VestingAlreadyExists(lockedWallet);\r\n        \r\n        // Create 33-month vesting schedule for locked wallet (Requirement 5.5)\r\n        // Changed from 34 to 33 months to match 3% monthly release (33  3% = 99%)\r\n        vestingSchedules[lockedWallet] = VestingSchedule({\r\n            totalAmount: amount,\r\n            releasedAmount: 0,\r\n            burnedAmount: 0,\r\n            startTime: block.timestamp,\r\n            cliffDuration: cliffDays * SECONDS_PER_DAY,\r\n            vestingDuration: 33 * SECONDS_PER_MONTH, // 33-month vesting (33  3% = 99%)\r\n            releasePercentage: LOCKED_MONTHLY_RELEASE, // 3% monthly (Requirement 5.1)\r\n            burnPercentage: PROPORTIONAL_BURN, // 10% burn (Requirements 5.2, 5.3, 5.4)\r\n            isAdmin: false,\r\n            isActive: true\r\n        });\r\n        \r\n        totalVestedAmount += amount;\r\n        \r\n        emit VestingScheduleCreated(\r\n            lockedWallet,\r\n            amount,\r\n            cliffDays * SECONDS_PER_DAY,\r\n            33 * SECONDS_PER_MONTH,\r\n            false\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Process locked wallet monthly release with proportional burning\r\n     * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\r\n     */\r\n    function processLockedWalletRelease(address lockedWallet) external onlyOwner returns (uint256 releasedAmount, uint256 burnedAmount) {\r\n        VestingSchedule storage schedule = vestingSchedules[lockedWallet];\r\n        \r\n        if (!schedule.isActive) revert NoVestingSchedule(lockedWallet);\r\n        if (schedule.isAdmin) revert InvalidVestingParameters(); // This function is for locked wallets only\r\n        \r\n        // Check if vesting has started\r\n        if (block.timestamp < schedule.startTime) revert VestingNotStarted(lockedWallet);\r\n        \r\n        // Check if cliff period has passed\r\n        if (block.timestamp < schedule.startTime + schedule.cliffDuration) revert CliffPeriodActive(lockedWallet);\r\n        \r\n        // Calculate available release amount using locked wallet logic\r\n        (uint256 availableAmount, uint256 burnAmount) = _calculateLockedWalletRelease(lockedWallet);\r\n        \r\n        if (availableAmount == 0) revert NoTokensToRelease(lockedWallet);\r\n        \r\n        // Update schedule tracking\r\n        schedule.releasedAmount += availableAmount;\r\n        schedule.burnedAmount += burnAmount;\r\n        \r\n        // Calculate actual amounts: 10% burn, 90% to locked wallet (Requirements 5.2, 5.3, 5.4)\r\n        burnedAmount = burnAmount;\r\n        releasedAmount = availableAmount - burnedAmount;\r\n        \r\n        // Transfer burn amount to dead wallet (Requirement 5.2)\r\n        _transfer(owner(), DEAD_WALLET, burnedAmount);\r\n        \r\n        // Transfer remaining 90% to locked wallet (Requirements 5.3, 5.4)\r\n        _transfer(owner(), lockedWallet, releasedAmount);\r\n        \r\n        // Update global tracking\r\n        totalReleasedAmount += availableAmount;\r\n        totalBurnedAmount += burnedAmount;\r\n        totalTokensBurned += burnedAmount;\r\n        \r\n        emit TokensReleased(lockedWallet, releasedAmount, burnedAmount, schedule.releasedAmount);\r\n        emit ProportionalBurn(lockedWallet, burnedAmount, totalBurnedAmount);\r\n        \r\n        return (releasedAmount, burnedAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate proportional burn amount for locked wallet release\r\n     * Requirements: 5.2, 5.3, 5.4 - 10% burn of released amount\r\n     */\r\n    function calculateProportionalBurn(address lockedWallet) external view returns (uint256 burnAmount, uint256 netReleaseAmount) {\r\n        (uint256 availableAmount, uint256 calculatedBurnAmount) = _calculateLockedWalletRelease(lockedWallet);\r\n        \r\n        burnAmount = calculatedBurnAmount;\r\n        netReleaseAmount = availableAmount - burnAmount;\r\n        \r\n        return (burnAmount, netReleaseAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get locked wallet vesting information\r\n     * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\r\n     */\r\n    function getLockedWalletInfo(address lockedWallet) external view returns (\r\n        uint256 totalAmount,\r\n        uint256 releasedAmount,\r\n        uint256 burnedAmount,\r\n        uint256 remainingAmount,\r\n        uint256 nextReleaseTime,\r\n        uint256 monthsElapsed,\r\n        uint256 monthsRemaining,\r\n        bool canRelease\r\n    ) {\r\n        VestingSchedule storage schedule = vestingSchedules[lockedWallet];\r\n        \r\n        if (!schedule.isActive) {\r\n            return (0, 0, 0, 0, 0, 0, 0, false);\r\n        }\r\n        \r\n        totalAmount = schedule.totalAmount;\r\n        releasedAmount = schedule.releasedAmount;\r\n        burnedAmount = schedule.burnedAmount;\r\n        remainingAmount = totalAmount - releasedAmount;\r\n        \r\n        // Calculate time-based information\r\n        uint256 cliffEndTime = schedule.startTime + schedule.cliffDuration;\r\n        uint256 vestingEndTime = schedule.startTime + schedule.cliffDuration + schedule.vestingDuration;\r\n        \r\n        if (block.timestamp < cliffEndTime) {\r\n            // Still in cliff period\r\n            nextReleaseTime = cliffEndTime;\r\n            monthsElapsed = 0;\r\n            monthsRemaining = schedule.vestingDuration / SECONDS_PER_MONTH;\r\n            canRelease = false;\r\n        } else if (block.timestamp >= vestingEndTime) {\r\n            // Vesting completed\r\n            monthsElapsed = schedule.vestingDuration / SECONDS_PER_MONTH;\r\n            monthsRemaining = 0;\r\n            nextReleaseTime = 0;\r\n            (uint256 available,) = _calculateLockedWalletRelease(lockedWallet);\r\n            canRelease = available > 0;\r\n        } else {\r\n            // In vesting period\r\n            uint256 timeElapsed = block.timestamp - cliffEndTime;\r\n            monthsElapsed = timeElapsed / SECONDS_PER_MONTH;\r\n            monthsRemaining = (schedule.vestingDuration / SECONDS_PER_MONTH) - monthsElapsed;\r\n            \r\n            // Next release time is at the start of next month\r\n            uint256 nextMonthStart = cliffEndTime + ((monthsElapsed + 1) * SECONDS_PER_MONTH);\r\n            nextReleaseTime = nextMonthStart;\r\n            \r\n            (uint256 available,) = _calculateLockedWalletRelease(lockedWallet);\r\n            canRelease = available > 0;\r\n        }\r\n        \r\n        return (totalAmount, releasedAmount, burnedAmount, remainingAmount, nextReleaseTime, monthsElapsed, monthsRemaining, canRelease);\r\n    }\r\n    \r\n    // ============================================\r\n    // AMM Management\r\n    // ============================================\r\n    \r\n    /**\r\n     * @dev Set AMM pair status\r\n     * @notice Trading control mechanism removed - trading enabled from deployment\r\n     */\r\n    function setAMMPair(address pair, bool isAMM) external onlyOwner {\r\n        require(pair != address(0), \"Invalid pair address\");\r\n        ammPairs[pair] = isAMM;\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if address is AMM pair\r\n     */\r\n    function isAMMPair(address pair) external view returns (bool) {\r\n        return ammPairs[pair];\r\n    }\r\n    \r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "evmVersion": "shanghai",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}